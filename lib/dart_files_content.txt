firebase_options.dart:
"// File generated by FlutterFire CLI.
// ignore_for_file: type=lint
import 'package:firebase_core/firebase_core.dart' show FirebaseOptions;
import 'package:flutter/foundation.dart'
    show defaultTargetPlatform, kIsWeb, TargetPlatform;

/// Default [FirebaseOptions] for use with your Firebase apps.
///
/// Example:
/// ```dart
/// import 'firebase_options.dart';
/// // ...
/// await Firebase.initializeApp(
///   options: DefaultFirebaseOptions.currentPlatform,
/// );
/// ```
class DefaultFirebaseOptions {
  static FirebaseOptions get currentPlatform {
    if (kIsWeb) {
      throw UnsupportedError(
        'DefaultFirebaseOptions have not been configured for web - '
        'you can reconfigure this by running the FlutterFire CLI again.',
      );
    }
    switch (defaultTargetPlatform) {
      case TargetPlatform.android:
        return android;
      case TargetPlatform.iOS:
        return ios;
      case TargetPlatform.macOS:
        throw UnsupportedError(
          'DefaultFirebaseOptions have not been configured for macos - '
          'you can reconfigure this by running the FlutterFire CLI again.',
        );
      case TargetPlatform.windows:
        throw UnsupportedError(
          'DefaultFirebaseOptions have not been configured for windows - '
          'you can reconfigure this by running the FlutterFire CLI again.',
        );
      case TargetPlatform.linux:
        throw UnsupportedError(
          'DefaultFirebaseOptions have not been configured for linux - '
          'you can reconfigure this by running the FlutterFire CLI again.',
        );
      default:
        throw UnsupportedError(
          'DefaultFirebaseOptions are not supported for this platform.',
        );
    }
  }

  static const FirebaseOptions android = FirebaseOptions(
    apiKey: 'AIzaSyDtRO6lIWQbEBIM7j9G5AE2YcflspW7yXc',
    appId: '1:116782521214:android:98e388a0cd2436e9aeb12f',
    messagingSenderId: '116782521214',
    projectId: 'masaratalnur',
    storageBucket: 'masaratalnur.firebasestorage.app',
  );

  static const FirebaseOptions ios = FirebaseOptions(
    apiKey: 'AIzaSyBX0eR6S7fbv22XXzac6DlipoTwKKGXTvQ',
    appId: '1:116782521214:ios:883734495ae7032aaeb12f',
    messagingSenderId: '116782521214',
    projectId: 'masaratalnur',
    storageBucket: 'masaratalnur.firebasestorage.app',
    androidClientId: '116782521214-084rkai81rvmk2mcrf2il05862o8gfk8.apps.googleusercontent.com',
    iosClientId: '116782521214-jhi8lrokp67pc38bj7lbijuu4nv3f44i.apps.googleusercontent.com',
    iosBundleId: 'com.oussama.masaratAlnur',
  );

}"

--------------------
main.dart:
"import 'package:firebase_core/firebase_core.dart';
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'firebase_options.dart';

// Import the new App Widget
import 'package:masarat_alnur/src/app.dart'; // Adjust path if needed

void main() async {
  WidgetsFlutterBinding.ensureInitialized();

  await Firebase.initializeApp(
    options: DefaultFirebaseOptions.currentPlatform,
  );

  runApp(
    const ProviderScope(
      child: MyApp(), // Use the actual App widget
    ),
  );
}"

--------------------
src\app.dart:
"// lib/src/app.dart

import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:go_router/go_router.dart';
import 'package:masarat_alnur/src/features/auth/data/auth_repository.dart';
import 'package:masarat_alnur/src/features/auth/data/user_repository.dart';
import 'package:masarat_alnur/src/features/content/domain/category.dart';
import 'package:flutter_gen/gen_l10n/app_localizations.dart';
import 'package:masarat_alnur/src/features/quiz/presentation/topic_list_screen.dart';
import 'package:masarat_alnur/src/features/quiz/presentation/quiz_screen.dart';

// Import Screens
import 'package:masarat_alnur/src/features/splash/presentation/splash_screen.dart';
import 'package:masarat_alnur/src/features/onboarding/presentation/welcome_screen.dart';
import 'package:masarat_alnur/src/features/auth/presentation/auth_screen_host.dart';
import 'package:masarat_alnur/src/features/onboarding/presentation/congrats_screen.dart';
import 'package:masarat_alnur/src/features/main_app/presentation/main_screen.dart';
import 'package:masarat_alnur/src/features/content/presentation/category_list_screen.dart';
import 'package:masarat_alnur/src/features/content/presentation/sub_category_list_screen.dart';
import 'package:masarat_alnur/src/features/content/data/content_repository.dart';

// --- App Routes ---
enum AppRoute {
  splash,
  // Onboarding steps
  onboardingWelcome,
  onboardingAuth,
  onboardingCongrats,
  // Main App
  main,
  // Content Routes
  categories,
  ongoingCategories,
  categorySubCategories,
  ongoingSubCategories,
  subCategoryTopics,
}

final goRouterProvider = Provider<GoRouter>((ref) {
  final authState = ref.watch(authStateChangesProvider);
  final userRepo = ref.read(userRepositoryProvider);
  final contentRepo = ref.read(contentRepositoryProvider);

  return GoRouter(
    initialLocation: '/splash',
    navigatorKey: GlobalKey<NavigatorState>(),
    debugLogDiagnostics: true,

    redirect: (BuildContext context, GoRouterState state) async {
      final bool loading = authState is AsyncLoading;
      final bool loggedIn = authState.valueOrNull != null;
      final String? currentUserId = authState.valueOrNull?.uid;

      final bool goingToSplash = state.matchedLocation == '/splash';
      final bool inAuthFlow = state.matchedLocation.startsWith('/onboarding');

      if (loading) {
        return goingToSplash ? null : '/splash';
      }

      if (!loggedIn) {
        return inAuthFlow ? null : '/onboarding/welcome';
      }

      // --- User is Logged In ---
      if (currentUserId != null) {
        final userProfile = await userRepo.fetchUser(currentUserId);
        
        if (userProfile != null) {
          // User exists in Firestore, go to main or congrats based on current location
          if (state.matchedLocation == '/onboarding/auth') {
            return '/onboarding/congrats';
          } else if (goingToSplash || (inAuthFlow && state.matchedLocation != '/onboarding/congrats')) {
            return '/main';
          }
          return null; // Stay on current screen
        } else {
          return '/onboarding/auth';
        }
      }
      
      return '/onboarding/welcome';
    },

    routes: [
      GoRoute(
        path: '/splash',
        name: AppRoute.splash.name,
        builder: (context, state) => const SplashScreen(),
      ),
      GoRoute(
        path: '/onboarding/welcome',
        name: AppRoute.onboardingWelcome.name,
        builder: (context, state) => const WelcomeScreen(),
      ),
      GoRoute(
        path: '/onboarding/auth',
        name: AppRoute.onboardingAuth.name,
        builder: (context, state) => const AuthScreenHost(),
      ),
      GoRoute(
        path: '/onboarding/congrats',
        name: AppRoute.onboardingCongrats.name,
        builder: (context, state) => const CongratsScreen(),
      ),
      GoRoute(
        path: '/main',
        name: AppRoute.main.name,
        builder: (context, state) => const MainScreen(),
      ),
      // Content Routes
      GoRoute(
        path: '/categories',
        name: AppRoute.categories.name,
        builder: (context, state) => const CategoryListScreen(),
      ),
      GoRoute(
        path: '/categories/ongoing',
        name: AppRoute.ongoingCategories.name,
        builder: (context, state) => const CategoryListScreen(ongoingOnly: true),
      ),
      GoRoute(
        path: '/categories/:categoryId/subcategories',
        name: AppRoute.categorySubCategories.name,
        builder: (context, state) {
          final categoryId = state.pathParameters['categoryId']!;
          return FutureBuilder<Category?>(
            future: contentRepo.fetchCategory(categoryId),
            builder: (context, snapshot) => SubCategoryListScreen(
              categoryId: categoryId,
              categoryName: snapshot.data?.title_ar,
            ),
          );
        },
      ),
      GoRoute(
        path: '/subcategories/ongoing',
        name: AppRoute.ongoingSubCategories.name,
        builder: (context, state) => const SubCategoryListScreen(ongoingOnly: true),
      ),
      GoRoute(
        path: '/subcategories/:subCategoryId/topics',
        name: AppRoute.subCategoryTopics.name,
        builder: (context, state) {
          final subCategoryId = state.pathParameters['subCategoryId']!;
          final subCategoryName = state.extra as String?;
          return TopicListScreen(
            subCategoryId: subCategoryId,
            subCategoryName: subCategoryName,
          );
        },
      ),
      GoRoute(
        path: '/topics/:topicId/quiz',
        builder: (context, state) {
          final topicId = state.pathParameters['topicId']!;
          return QuizScreen(topicId: topicId);
        },
      ),
    ],
    errorBuilder: (context, state) => Scaffold(
        body: Center(child: Text('Page not found: ${state.error}')),
    ),
  );
});

// --- Main Application Widget (Updated for Localization) ---
class MyApp extends ConsumerWidget {
  const MyApp({super.key});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final goRouter = ref.watch(goRouterProvider);

    return MaterialApp.router(
      routerConfig: goRouter,
      title: 'Masarat AlNur',

      // --- Localization Setup ---
      localizationsDelegates: AppLocalizations.localizationsDelegates,
      supportedLocales: AppLocalizations.supportedLocales,
      locale: const Locale('ar'),
      // --- End Localization Setup ---

      theme: ThemeData(
        colorScheme: ColorScheme.fromSeed(
          seedColor: Colors.deepPurple,
        ),
        useMaterial3: true,
      ),
      debugShowCheckedModeBanner: false,
    );
  }
}"

--------------------
src\features\auth\data\auth_repository.dart:
"import 'package:firebase_auth/firebase_auth.dart' as fb_auth; // Alias FirebaseAuth
import 'package:google_sign_in/google_sign_in.dart';
import 'package:riverpod_annotation/riverpod_annotation.dart';

import '../domain/app_user.dart'; // Import AppUser model

part 'auth_repository.g.dart'; // Riverpod generator

// Define AuthResult equivalent in Dart (using sealed class/Freezed)
sealed class AuthResult<T> {
  const AuthResult();
}

class AuthSuccess<T> extends AuthResult<T> {
  final T data;
  const AuthSuccess(this.data);
}

class AuthError<T> extends AuthResult<T> {
  final Exception exception;
  const AuthError(this.exception);
}

// --- Auth Repository using Riverpod for dependency injection ---
class AuthRepository {
  final fb_auth.FirebaseAuth _firebaseAuth;
  final GoogleSignIn _googleSignIn; // For Google Sign-Out

  AuthRepository(this._firebaseAuth, this._googleSignIn);

  // Expose auth state changes stream mapped to AppUser or null
  Stream<AppUser?> authStateChanges() {
    return _firebaseAuth.authStateChanges().map(_appUserFromFirebase);
  }

  AppUser? get currentUser => _appUserFromFirebase(_firebaseAuth.currentUser);

  // Helper to convert FirebaseUser to AppUser
  AppUser? _appUserFromFirebase(fb_auth.User? user) {
    if (user == null) {
      return null;
    }
    // We fetch role and potentially displayName override from Firestore,
    // so this conversion might be preliminary. A UserRepo fetch is needed
    // for the complete AppUser profile after auth.
    return AppUser(
      uid: user.uid,
      email: user.email ?? '',
      displayName: user.displayName, // Use Firebase display name initially if available
      // Role needs to be fetched from Firestore
    );
  }

  Future<AuthResult<fb_auth.User>> signUpWithEmailPassword(String email, String password) async {
    try {
      final credential = await _firebaseAuth.createUserWithEmailAndPassword(
          email: email, password: password);
      return AuthSuccess(credential.user!);
    } on fb_auth.FirebaseAuthException catch (e) {
      return AuthError(e);
    } catch (e) {
      return AuthError(Exception(e.toString()));
    }
  }

   Future<AuthResult<fb_auth.User>> signInWithEmailPassword(String email, String password) async {
    try {
      final credential = await _firebaseAuth.signInWithEmailAndPassword(
          email: email, password: password);
      return AuthSuccess(credential.user!);
    } on fb_auth.FirebaseAuthException catch (e) {
      return AuthError(e);
    } catch (e) {
       return AuthError(Exception(e.toString()));
    }
  }

   Future<AuthResult<fb_auth.User>> signInWithGoogle() async {
     try {
       final GoogleSignInAccount? googleUser = await _googleSignIn.signIn();
       if (googleUser == null) {
         // User cancelled the sign-in
         return AuthError(Exception("Google Sign-In cancelled by user."));
       }
       final GoogleSignInAuthentication googleAuth = await googleUser.authentication;
       final fb_auth.AuthCredential credential = fb_auth.GoogleAuthProvider.credential(
         accessToken: googleAuth.accessToken,
         idToken: googleAuth.idToken,
       );
       final userCredential = await _firebaseAuth.signInWithCredential(credential);
       return AuthSuccess(userCredential.user!);
     } on fb_auth.FirebaseAuthException catch (e) {
       return AuthError(e);
     } catch (e) {
        return AuthError(Exception(e.toString()));
     }
   }

   Future<void> sendPasswordResetEmail(String email) async {
     // Doesn't return Result here, exceptions handled by caller/ViewModel
     await _firebaseAuth.sendPasswordResetEmail(email: email);
   }


   Future<void> signOut() async {
     await _firebaseAuth.signOut();
     // Also sign out from Google if needed to ensure account chooser appears next time
     // Check if last sign in was Google? Or just sign out anyway.
     final isSignedIn = await _googleSignIn.isSignedIn();
      if (isSignedIn) {
        await _googleSignIn.signOut();
      }
   }
}

// --- Riverpod Providers ---

@Riverpod(keepAlive: true) // Keep auth instance alive globally
fb_auth.FirebaseAuth firebaseAuth(FirebaseAuthRef ref) {
  return fb_auth.FirebaseAuth.instance;
}

@Riverpod(keepAlive: true) // Keep google sign in instance alive
GoogleSignIn googleSignIn(GoogleSignInRef ref) {
   // You might need to pass client IDs here if web support is added later
   return GoogleSignIn();
}


@Riverpod(keepAlive: true) // Keep repository alive
AuthRepository authRepository(AuthRepositoryRef ref) {
  return AuthRepository(ref.watch(firebaseAuthProvider), ref.watch(googleSignInProvider));
}

// Stream provider for auth state changes -> AppUser?
@riverpod
Stream<AppUser?> authStateChanges(AuthStateChangesRef ref) {
  return ref.watch(authRepositoryProvider).authStateChanges();
}"

--------------------
src\features\auth\data\auth_repository.g.dart:
"// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'auth_repository.dart';

// **************************************************************************
// RiverpodGenerator
// **************************************************************************

String _$firebaseAuthHash() => r'38a6dd5bbf470a905629b5f18e606df31706d493';

/// See also [firebaseAuth].
@ProviderFor(firebaseAuth)
final firebaseAuthProvider = Provider<fb_auth.FirebaseAuth>.internal(
  firebaseAuth,
  name: r'firebaseAuthProvider',
  debugGetCreateSourceHash:
      const bool.fromEnvironment('dart.vm.product') ? null : _$firebaseAuthHash,
  dependencies: null,
  allTransitiveDependencies: null,
);

@Deprecated('Will be removed in 3.0. Use Ref instead')
// ignore: unused_element
typedef FirebaseAuthRef = ProviderRef<fb_auth.FirebaseAuth>;
String _$googleSignInHash() => r'33e2d830c18590dbfdef7f4796eb1120b7e87104';

/// See also [googleSignIn].
@ProviderFor(googleSignIn)
final googleSignInProvider = Provider<GoogleSignIn>.internal(
  googleSignIn,
  name: r'googleSignInProvider',
  debugGetCreateSourceHash:
      const bool.fromEnvironment('dart.vm.product') ? null : _$googleSignInHash,
  dependencies: null,
  allTransitiveDependencies: null,
);

@Deprecated('Will be removed in 3.0. Use Ref instead')
// ignore: unused_element
typedef GoogleSignInRef = ProviderRef<GoogleSignIn>;
String _$authRepositoryHash() => r'd194f2ebd7a0ee2654292b86193bf77c2d8f59a2';

/// See also [authRepository].
@ProviderFor(authRepository)
final authRepositoryProvider = Provider<AuthRepository>.internal(
  authRepository,
  name: r'authRepositoryProvider',
  debugGetCreateSourceHash:
      const bool.fromEnvironment('dart.vm.product')
          ? null
          : _$authRepositoryHash,
  dependencies: null,
  allTransitiveDependencies: null,
);

@Deprecated('Will be removed in 3.0. Use Ref instead')
// ignore: unused_element
typedef AuthRepositoryRef = ProviderRef<AuthRepository>;
String _$authStateChangesHash() => r'c00e905be3d1427e13cd3e958c86fb964ebab96c';

/// See also [authStateChanges].
@ProviderFor(authStateChanges)
final authStateChangesProvider = AutoDisposeStreamProvider<AppUser?>.internal(
  authStateChanges,
  name: r'authStateChangesProvider',
  debugGetCreateSourceHash:
      const bool.fromEnvironment('dart.vm.product')
          ? null
          : _$authStateChangesHash,
  dependencies: null,
  allTransitiveDependencies: null,
);

@Deprecated('Will be removed in 3.0. Use Ref instead')
// ignore: unused_element
typedef AuthStateChangesRef = AutoDisposeStreamProviderRef<AppUser?>;
// ignore_for_file: type=lint
// ignore_for_file: subtype_of_sealed_class, invalid_use_of_internal_member, invalid_use_of_visible_for_testing_member, deprecated_member_use_from_same_package
"

--------------------
src\features\auth\data\user_repository.dart:
"import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:firebase_auth/firebase_auth.dart' as fb_auth;
import 'package:riverpod_annotation/riverpod_annotation.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart'; // Import base Ref

import 'package:masarat_alnur/src/features/auth/data/auth_repository.dart'; // For firebaseAuth provider
import 'package:masarat_alnur/src/features/auth/domain/app_user.dart';
import 'package:masarat_alnur/src/features/progress/domain/user_progress.dart';

part 'user_repository.g.dart'; // Riverpod generator

class UserRepository {
  final FirebaseFirestore _firestore;
  UserRepository(this._firestore);

  // Reference to 'users' collection
  CollectionReference<AppUser> _usersRef() =>
      _firestore.collection('users').withConverter<AppUser>(
            fromFirestore: (snapshot, _) => AppUser( // Simple fromFirestore for AppUser
               uid: snapshot.id,
               email: snapshot.data()?['email'] ?? '',
               displayName: snapshot.data()?['displayName'],
               role: snapshot.data()?['role'] ?? 'user',
            ),
            toFirestore: (user, _) => { // Simple toFirestore
              // Don't write UID to fields, it's the doc ID
              'email': user.email,
              if (user.displayName != null) 'displayName': user.displayName,
              'role': user.role,
              // Add other fields if necessary, like profileImageUrl
            },
          );

   // Reference to 'userProgress' collection
   CollectionReference<UserProgress> _progressRef() =>
       _firestore.collection('userProgress').withConverter<UserProgress>(
             fromFirestore: UserProgress.fromFirestore, // Use factory from model
             toFirestore: (progress, _) => progress.toFirestore(), // Use method from model
           );


  // --- User Profile Methods ---

  // Fetch user profile data once
  Future<AppUser?> fetchUser(String userId) async {
    try {
      final snapshot = await _usersRef().doc(userId).get();
      return snapshot.data(); // Returns AppUser?
    } catch (e) {
      print("Error fetching user $userId: $e");
      return null;
    }
  }

  // Stream user profile data
   Stream<AppUser?> watchUser(String userId) {
     return _usersRef()
         .doc(userId)
         .snapshots() // Listen to snapshot changes
         .map((snapshot) => snapshot.data()); // Map snapshot to AppUser?
   }

  // Create user document (only if it doesn't exist)
  Future<void> createUserDocument(fb_auth.User firebaseUser) async {
    final userDocRef = _usersRef().doc(firebaseUser.uid);
    final snapshot = await userDocRef.get();

    if (!snapshot.exists) {
       print("Creating user document for ${firebaseUser.uid}");
      // Generate display name from email (everything before @)
      final displayName = firebaseUser.email?.split('@')[0] ?? 'User';
      
      final newUser = AppUser(
        uid: firebaseUser.uid,
        email: firebaseUser.email ?? '',
        displayName: displayName, // Use generated display name
        role: 'user',
      );
      await userDocRef.set(newUser);
    } else {
       print("User document already exists for ${firebaseUser.uid}");
       // Optionally update existing doc with latest email from Firebase
       await userDocRef.update({'email': firebaseUser.email});
    }
  }

  // Update specific user data (like displayName)
   Future<void> updateUserData(String userId, {String? displayName}) async {
      final Map<String, dynamic> dataToUpdate = {};
      if (displayName != null) {
        dataToUpdate['displayName'] = displayName;
      }
       // Add other updatable fields here if needed
      if (dataToUpdate.isNotEmpty) {
        await _usersRef().doc(userId).update(dataToUpdate);
      }
   }

  Future<bool> isAdmin(String userId) async {
    if (userId.isEmpty) return false;
    try {
      final userDoc = await _usersRef().doc(userId).get();
      final userData = userDoc.data();
      return userData?.role == 'admin';
    } catch (e) {
      print("Error checking admin status for $userId: $e");
      return false;
    }
  }


  // --- User Progress Methods ---
  
   Stream<UserProgress?> watchUserProgress(String userId) {
     if (userId.isEmpty) return Stream.value(null);
     return _progressRef()
         .doc(userId)
         .snapshots()
         .map((snapshot) => snapshot.data())
         .handleError((error) { // Handle errors in the stream
           print("Error watching user progress for $userId: $error");
           return null; // Emit null on error
         });
   }

   Future<UserProgress?> fetchUserProgressOnce(String userId) async {
      if (userId.isEmpty) return null;
      try {
        final snapshot = await _progressRef().doc(userId).get();
        return snapshot.data();
      } catch (e) {
        print("Error fetching user progress once for $userId: $e");
        return null;
      }
   }

    Future<void> createInitialUserProgress(String userId) async {
      if (userId.isEmpty) return;
      final progressDocRef = _progressRef().doc(userId);
      final snapshot = await progressDocRef.get();
      if (!snapshot.exists) {
        print("Creating initial UserProgress for $userId");
        await progressDocRef.set(UserProgress.empty()); // Create empty progress doc
      }
    }

    Future<void> markTopicAsComplete(String userId, String topicId) async {
      if (userId.isEmpty || topicId.isEmpty) return;
      
      // Add to completed topics
      await _progressRef().doc(userId).update({
        'completedTopicIds': FieldValue.arrayUnion([topicId]),
        'lastUpdatedAt': FieldValue.serverTimestamp(),
      });

      // Check if subcategory is complete
      final topic = await _firestore.collection('topics').doc(topicId).get();
      if (topic.exists) {
        final subCategoryId = topic.data()?['subCategoryId'] as String?;
        if (subCategoryId != null) {
          await _checkAndUpdateSubCategoryCompletion(userId, subCategoryId);
        }
      }
    }

   Future<void> updateSubCategoryStarted(String userId, String subCategoryId) async {
       if (userId.isEmpty || subCategoryId.isEmpty) return;
       // Use dot notation with update to set a specific field within the map
       final fieldPath = 'startedSubCategoryInfo';
       await _progressRef().doc(userId).update({
         fieldPath: FieldValue.arrayUnion([subCategoryId]),
         'lastUpdatedAt': FieldValue.serverTimestamp(),
       });
     }

    Future<void> markSubCategoryAsComplete(String userId, String subCategoryId) async {
      if (userId.isEmpty || subCategoryId.isEmpty) return;
      await _progressRef().doc(userId).update({
        'completedSubCategoryIds': FieldValue.arrayUnion([subCategoryId]),
        'lastUpdatedAt': FieldValue.serverTimestamp(),
      });
    }

   Future<void> updateCategoryStarted(String userId, String categoryId) async {
       if (userId.isEmpty || categoryId.isEmpty) return;
       final fieldPath = 'startedCategoryInfo';
       await _progressRef().doc(userId).update({
         fieldPath: FieldValue.arrayUnion([categoryId]),
         'lastUpdatedAt': FieldValue.serverTimestamp(),
       });
     }

    Future<void> markCategoryAsComplete(String userId, String categoryId) async {
       if (userId.isEmpty || categoryId.isEmpty) return;
       await _progressRef().doc(userId).update({
         'completedCategoryIds': FieldValue.arrayUnion([categoryId]),
         'lastUpdatedAt': FieldValue.serverTimestamp(),
       });
     }

    Future<void> _checkAndUpdateSubCategoryCompletion(String userId, String subCategoryId) async {
      // Get all topics in the subcategory
      final topicsSnapshot = await _firestore
          .collection('topics')
          .where('subCategoryId', isEqualTo: subCategoryId)
          .where('status', isEqualTo: 'PUBLISHED')
          .get();

      // Get user progress
      final userProgress = await fetchUserProgressOnce(userId);
      if (userProgress == null) return;

      final completedTopicIds = userProgress.completedTopicIds;
      final isComplete = topicsSnapshot.docs.every(
          (doc) => completedTopicIds.contains(doc.id));

      if (isComplete) {
        // Get category ID for the subcategory
        final subCategory = await _firestore
            .collection('subCategories')
            .doc(subCategoryId)
            .get();
        
        final categoryId = subCategory.data()?['categoryId'] as String?;

        // Remove from started and add to completed
        await _progressRef().doc(userId).update({
          'startedSubCategoryInfo': FieldValue.arrayRemove([subCategoryId]),
          'completedSubCategoryIds': FieldValue.arrayUnion([subCategoryId]),
          'lastUpdatedAt': FieldValue.serverTimestamp(),
        });

        if (categoryId != null) {
          await _checkAndUpdateCategoryCompletion(userId, categoryId);
        }
      }
    }

    Future<void> _checkAndUpdateCategoryCompletion(String userId, String categoryId) async {
      // Get all subcategories in the category
      final subCategoriesSnapshot = await _firestore
          .collection('subCategories')
          .where('categoryId', isEqualTo: categoryId)
          .where('status', isEqualTo: 'PUBLISHED')
          .get();

      // Get user progress
      final userProgress = await fetchUserProgressOnce(userId);
      if (userProgress == null) return;

      final completedSubCategoryIds = userProgress.completedSubCategoryIds;
      final isComplete = subCategoriesSnapshot.docs.every(
          (doc) => completedSubCategoryIds.contains(doc.id));

      if (isComplete) {
        // Remove from started and add to completed
        await _progressRef().doc(userId).update({
          'startedCategoryInfo': FieldValue.arrayRemove([categoryId]),
          'completedCategoryIds': FieldValue.arrayUnion([categoryId]),
          'lastUpdatedAt': FieldValue.serverTimestamp(),
        });
      }
    }
}


// --- Riverpod Providers (Fixing Deprecation Warnings) ---
@Riverpod(keepAlive: true)
FirebaseFirestore firebaseFirestore(FirebaseFirestoreRef ref) { // Keep specific Ref here for generator
  return FirebaseFirestore.instance;
}

@riverpod
UserRepository userRepository(UserRepositoryRef ref) { // Keep specific Ref here for generator
  return UserRepository(ref.watch(firebaseFirestoreProvider));
}

// Provider to watch the current logged-in user's AppUser profile from Firestore
@riverpod
Stream<AppUser?> userProfileStream(Ref ref) { // Use generic Ref
   final authRepo = ref.watch(authRepositoryProvider);
   final userRepo = ref.watch(userRepositoryProvider);
   return authRepo.authStateChanges().asyncMap((firebaseUser) {
      if (firebaseUser != null) {
         return userRepo.fetchUser(firebaseUser.uid); // Fetch profile on auth change
      } else {
         return null;
      }
   });
}


// Provider to watch the current user's progress document
@riverpod
Stream<UserProgress?> userProgressStream(Ref ref) { // Use generic Ref
   // Watch the auth state directly to get the UID reactively
   final asyncUser = ref.watch(authStateChangesProvider);
   final userId = asyncUser.value?.uid; // Safely get UID from AsyncValue

   if (userId != null && userId.isNotEmpty) {
      // Use watch instead of read if you want userRepo dependency to be tracked
      return ref.watch(userRepositoryProvider).watchUserProgress(userId);
   } else {
      return Stream.value(null); // No user logged in
   }
}

// Provider to check if the current user is an admin
@riverpod
Future<bool> isCurrentUserAdmin(Ref ref) async {
  final asyncUser = ref.watch(authStateChangesProvider);
  final userId = asyncUser.value?.uid;
  if (userId == null) return false;
  
  return ref.watch(userRepositoryProvider).isAdmin(userId);
}"

--------------------
src\features\auth\data\user_repository.g.dart:
"// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'user_repository.dart';

// **************************************************************************
// RiverpodGenerator
// **************************************************************************

String _$firebaseFirestoreHash() => r'2e7f8bd195d91c027c5155f34b719187867bc113';

/// See also [firebaseFirestore].
@ProviderFor(firebaseFirestore)
final firebaseFirestoreProvider = Provider<FirebaseFirestore>.internal(
  firebaseFirestore,
  name: r'firebaseFirestoreProvider',
  debugGetCreateSourceHash:
      const bool.fromEnvironment('dart.vm.product')
          ? null
          : _$firebaseFirestoreHash,
  dependencies: null,
  allTransitiveDependencies: null,
);

@Deprecated('Will be removed in 3.0. Use Ref instead')
// ignore: unused_element
typedef FirebaseFirestoreRef = ProviderRef<FirebaseFirestore>;
String _$userRepositoryHash() => r'bb46dbd1dece5adb6befe8d60db6c1998d18f411';

/// See also [userRepository].
@ProviderFor(userRepository)
final userRepositoryProvider = AutoDisposeProvider<UserRepository>.internal(
  userRepository,
  name: r'userRepositoryProvider',
  debugGetCreateSourceHash:
      const bool.fromEnvironment('dart.vm.product')
          ? null
          : _$userRepositoryHash,
  dependencies: null,
  allTransitiveDependencies: null,
);

@Deprecated('Will be removed in 3.0. Use Ref instead')
// ignore: unused_element
typedef UserRepositoryRef = AutoDisposeProviderRef<UserRepository>;
String _$userProfileStreamHash() => r'aa57370fe9e5ad99fe7dd175a306ac13ce27e9d9';

/// See also [userProfileStream].
@ProviderFor(userProfileStream)
final userProfileStreamProvider = AutoDisposeStreamProvider<AppUser?>.internal(
  userProfileStream,
  name: r'userProfileStreamProvider',
  debugGetCreateSourceHash:
      const bool.fromEnvironment('dart.vm.product')
          ? null
          : _$userProfileStreamHash,
  dependencies: null,
  allTransitiveDependencies: null,
);

@Deprecated('Will be removed in 3.0. Use Ref instead')
// ignore: unused_element
typedef UserProfileStreamRef = AutoDisposeStreamProviderRef<AppUser?>;
String _$userProgressStreamHash() =>
    r'7b70fcd319b16eeaadcd720e00510f184bd257cb';

/// See also [userProgressStream].
@ProviderFor(userProgressStream)
final userProgressStreamProvider =
    AutoDisposeStreamProvider<UserProgress?>.internal(
      userProgressStream,
      name: r'userProgressStreamProvider',
      debugGetCreateSourceHash:
          const bool.fromEnvironment('dart.vm.product')
              ? null
              : _$userProgressStreamHash,
      dependencies: null,
      allTransitiveDependencies: null,
    );

@Deprecated('Will be removed in 3.0. Use Ref instead')
// ignore: unused_element
typedef UserProgressStreamRef = AutoDisposeStreamProviderRef<UserProgress?>;
String _$isCurrentUserAdminHash() =>
    r'8a4dbd1621e927f9cc31b29ba8391986c5e95608';

/// See also [isCurrentUserAdmin].
@ProviderFor(isCurrentUserAdmin)
final isCurrentUserAdminProvider = AutoDisposeFutureProvider<bool>.internal(
  isCurrentUserAdmin,
  name: r'isCurrentUserAdminProvider',
  debugGetCreateSourceHash:
      const bool.fromEnvironment('dart.vm.product')
          ? null
          : _$isCurrentUserAdminHash,
  dependencies: null,
  allTransitiveDependencies: null,
);

@Deprecated('Will be removed in 3.0. Use Ref instead')
// ignore: unused_element
typedef IsCurrentUserAdminRef = AutoDisposeFutureProviderRef<bool>;
// ignore_for_file: type=lint
// ignore_for_file: subtype_of_sealed_class, invalid_use_of_internal_member, invalid_use_of_visible_for_testing_member, deprecated_member_use_from_same_package
"

--------------------
src\features\auth\domain\app_user.dart:
"// Using Equatable for simpler value comparison if not using Freezed
import 'package:equatable/equatable.dart';


class AppUser extends Equatable {
  final String uid;
  final String email;
  final String? displayName; // Nullable, presence indicates onboarding nickname step complete
  final String role; // Added role from previous discussion

  const AppUser({
    required this.uid,
    required this.email,
    this.displayName,
    this.role = 'user', // Default role
  });

  // Factory constructor for creating a default/empty user
  factory AppUser.empty() => const AppUser(uid: '', email: '', displayName: null, role: 'user');

   // --- If using Equatable ---
   @override
   List<Object?> get props => [uid, email, displayName, role];

   @override
   bool get stringify => true;
  // --- End Equatable ---


  // Helper method to check if nickname onboarding is done
  bool get isNicknameComplete => displayName != null && displayName!.isNotEmpty;

  // Copy method (provided by Freezed or Equatable, or implement manually)
  AppUser copyWith({
    String? uid,
    String? email,
    String? displayName,
     bool clearDisplayName = false, // Flag to explicitly set displayName to null
    String? role,
  }) {
    return AppUser(
      uid: uid ?? this.uid,
      email: email ?? this.email,
      // Handle clearing vs updating displayName
      displayName: clearDisplayName ? null : (displayName ?? this.displayName),
      role: role ?? this.role,
    );
  }
}"

--------------------
src\features\auth\presentation\auth_screen_host.dart:
"import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:go_router/go_router.dart';
import 'package:masarat_alnur/src/app.dart'; // For AppRoute
import 'package:masarat_alnur/src/features/auth/presentation/login_view.dart'; // Create this widget
import 'package:masarat_alnur/src/features/auth/presentation/signup_view.dart'; // Create this widget
import 'package:masarat_alnur/src/features/auth/presentation/auth_view_model.dart'; // Import ViewModel
import 'package:masarat_alnur/src/utils/async_value_ui.dart'; // Create this helper
import 'package:flutter_gen/gen_l10n/app_localizations.dart';

class AuthScreenHost extends ConsumerStatefulWidget {
  const AuthScreenHost({super.key});

  @override
  ConsumerState<AuthScreenHost> createState() => _AuthScreenHostState();
}

class _AuthScreenHostState extends ConsumerState<AuthScreenHost>
    with SingleTickerProviderStateMixin { // For TabController
  late TabController _tabController;

  @override
  void initState() {
    super.initState();
    _tabController = TabController(length: 2, vsync: this);
    WidgetsBinding.instance.addPostFrameCallback((_) {
      ref.read(authViewModelProvider.notifier).resetUiStateToIdle();
    });
  }

  @override
  void dispose() {
    _tabController.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    final l10n = AppLocalizations.of(context)!;

    // --- Listen to ViewModel state for navigation / errors ---
    ref.listen<AuthUiState>(authViewModelProvider, (_, state) { // Listen to state provider
      // Show snackbar on error
       state.showSnackBarOnError(context); // Use extension method

      // Navigate on success state AFTER auth
      if (state is AuthUiAuthSuccessful) {
        // Auth is done (login or signup), move to congrats screen
        context.goNamed(AppRoute.onboardingCongrats.name);
        // Reset state after handling navigation
        ref.read(authViewModelProvider.notifier).resetUiStateToIdle();
      }
    });

    return Scaffold(
      appBar: AppBar(
        title: Text(l10n.appTitle), // Or specific auth title
        bottom: TabBar(
          controller: _tabController,
          tabs: [
            Tab(text: l10n.loginTitle),
            Tab(text: l10n.signupTitle),
          ],
        ),
      ),
      body: SafeArea(
        child: TabBarView(
          controller: _tabController,
          children: [
            // Pass the callback to switch tabs
            LoginView(onGoToSignUp: () => _tabController.animateTo(1)),
            SignUpView(onGoToSignIn: () => _tabController.animateTo(0)),
          ],
        ),
      ),
    );
  }
}
"

--------------------
src\features\auth\presentation\auth_view_model.dart:
"import 'dart:async'; // For Completer maybe if needed

import 'package:google_sign_in/google_sign_in.dart';
import 'package:masarat_alnur/src/features/auth/data/auth_repository.dart';
import 'package:masarat_alnur/src/features/auth/data/user_repository.dart';
import 'package:firebase_auth/firebase_auth.dart' as fb_auth; // Alias
import 'package:riverpod_annotation/riverpod_annotation.dart';

part 'auth_view_model.g.dart'; // Riverpod generator

sealed class AuthUiState {
  const AuthUiState();
}

class AuthUiInitial extends AuthUiState { const AuthUiInitial(); } // Initial state
class AuthUiLoading extends AuthUiState { const AuthUiLoading(); } // Show progress indicator
class AuthUiError extends AuthUiState {
  final String message;
  const AuthUiError(this.message);
}
class AuthUiPasswordResetSent extends AuthUiState { const AuthUiPasswordResetSent(); }
class AuthUiAuthSuccessful extends AuthUiState { // Trigger navigation within onboarding
  final fb_auth.User user; // Pass user if needed by next step
  const AuthUiAuthSuccessful(this.user);
}

// --- ViewModel using Riverpod Generator ---
@riverpod 
class AuthViewModel extends _$AuthViewModel {

  // Build method required by generator, sets initial state
  @override
  AuthUiState build() {
    // No initial async work needed here to build the state itself
    return const AuthUiInitial();
  }

  // Helper method to get repositories (dependencies injected by Riverpod)
  AuthRepository get _authRepository => ref.read(authRepositoryProvider);
  UserRepository get _userRepository => ref.read(userRepositoryProvider);

  // --- Sign Up ---
  Future<void> signUpWithEmailPassword(String email, String pass) async {
    state = const AuthUiLoading(); // Set loading state
    final result = await _authRepository.signUpWithEmailPassword(email, pass);
    switch (result) {
      case AuthSuccess(data: final user):
        print("AuthViewModel: Sign up success for ${user.email}");
        try {
          await _userRepository.createUserDocument(user);
          await _userRepository.createInitialUserProgress(user.uid); // Ensure progress doc
          print("AuthViewModel: User/Progress document ensured after signup.");
          state = AuthUiAuthSuccessful(user); // Signal success for navigation
        } catch (e) {
           print("AuthViewModel: Signup success BUT failed user/progress doc creation: $e");
           state = AuthUiError("Account created, but profile setup failed: ${e.toString()}");
           // Consider attempting cleanup? (e.g., delete the auth user) - complex!
        }
      case AuthError(exception: final e):
        print("AuthViewModel: Sign up error: $e");
        state = AuthUiError(e.toString()); // Use e.message or map specific FirebaseAuthExceptions
    }
  }

  // --- Sign In ---
  Future<void> signInWithEmailPassword(String email, String pass) async {
    state = const AuthUiLoading();
    final result = await _authRepository.signInWithEmailPassword(email, pass);
    await _handleSignInResult(result); // Use common handler
  }

  Future<void> signInWithGoogle() async {
    state = const AuthUiLoading();
    // Use GoogleSignIn instance from its provider
    final googleSignIn = ref.read(googleSignInProvider);
    try {
       final GoogleSignInAccount? googleUser = await googleSignIn.signIn();
       if (googleUser == null) {
          state = const AuthUiInitial(); // User cancelled
          return;
       }
       final result = await _authRepository.signInWithGoogle(); 
       await _handleSignInResult(result);
    } catch(e) {
       print("AuthViewModel: Google Sign In method error: $e");
       state = AuthUiError("Google Sign-In failed: ${e.toString()}");
    }
  }

  // --- Common Handler for Sign In Results ---
  Future<void> _handleSignInResult(AuthResult<fb_auth.User> result) async {
    switch (result) {
      case AuthSuccess(data: final user):
        print("AuthViewModel: Sign in success for ${user.email}");
        // Ensure user document exists (includes initial progress doc creation)
        try {
           await _userRepository.createUserDocument(user);
           await _userRepository.createInitialUserProgress(user.uid); // Ensure progress doc
           print("AuthViewModel: User/Progress document ensured after signin.");
           state = AuthUiAuthSuccessful(user); // Signal success for navigation
        } catch (e) {
           print("AuthViewModel: Signin success BUT failed user/progress doc creation: $e");
           state = AuthUiError("Login successful, but profile setup failed: ${e.toString()}");
           await _authRepository.signOut();
        }
      case AuthError(exception: final e):
        print("AuthViewModel: Sign in error: $e");
        state = AuthUiError(e.toString());
    }
  }


  // --- Forgot Password ---
  Future<void> sendPasswordResetEmail(String email) async {
    state = const AuthUiLoading();
    try {
       await _authRepository.sendPasswordResetEmail(email);
       state = const AuthUiPasswordResetSent();
    } catch(e) {
       print("AuthViewModel: Password reset error: $e");
       state = AuthUiError(e.toString());
    }
    // Optionally reset state after a delay?
     await Future.delayed(const Duration(seconds: 2));
     if (state is AuthUiPasswordResetSent || state is AuthUiError) {
       resetUiStateToIdle();
     }
  }

  // Function to reset UI state if needed after an event is handled
  void resetUiStateToIdle() {
    if (state is! AuthUiLoading) {
      state = const AuthUiInitial();
    }
  }
}"

--------------------
src\features\auth\presentation\auth_view_model.g.dart:
"// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'auth_view_model.dart';

// **************************************************************************
// RiverpodGenerator
// **************************************************************************

String _$authViewModelHash() => r'a646e743d5f51cb74b403077a8d4dc8db4d50c2f';

/// See also [AuthViewModel].
@ProviderFor(AuthViewModel)
final authViewModelProvider =
    AutoDisposeNotifierProvider<AuthViewModel, AuthUiState>.internal(
      AuthViewModel.new,
      name: r'authViewModelProvider',
      debugGetCreateSourceHash:
          const bool.fromEnvironment('dart.vm.product')
              ? null
              : _$authViewModelHash,
      dependencies: null,
      allTransitiveDependencies: null,
    );

typedef _$AuthViewModel = AutoDisposeNotifier<AuthUiState>;
// ignore_for_file: type=lint
// ignore_for_file: subtype_of_sealed_class, invalid_use_of_internal_member, invalid_use_of_visible_for_testing_member, deprecated_member_use_from_same_package
"

--------------------
src\features\auth\presentation\login_view.dart:
"import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:masarat_alnur/src/features/auth/presentation/auth_view_model.dart';
import 'package:flutter_gen/gen_l10n/app_localizations.dart';
import 'package:masarat_alnur/src/utils/async_value_ui.dart'; // For snackbar helper

class LoginView extends ConsumerStatefulWidget {
  final VoidCallback onGoToSignUp; // Callback to switch tabs

  const LoginView({super.key, required this.onGoToSignUp});

  @override
  ConsumerState<LoginView> createState() => _LoginViewState();
}

class _LoginViewState extends ConsumerState<LoginView> {
  final _formKey = GlobalKey<FormState>();
  final _emailController = TextEditingController();
  final _passwordController = TextEditingController();

  @override
  void dispose() {
    _emailController.dispose();
    _passwordController.dispose();
    super.dispose();
  }

  Future<void> _submit() async {
    if (_formKey.currentState!.validate()) {
      final email = _emailController.text.trim();
      final password = _passwordController.text.trim();
      // Call ViewModel method
      ref
          .read(authViewModelProvider.notifier)
          .signInWithEmailPassword(email, password);
    }
  }

   Future<void> _submitGoogle() async {
     ref.read(authViewModelProvider.notifier).signInWithGoogle();
   }

   Future<void> _forgotPassword() async {
       final email = _emailController.text.trim();
       if (email.isEmpty || !RegExp(r"^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$").hasMatch(email)){
            // Show prompt to enter email first
            ScaffoldMessenger.of(context)..hideCurrentSnackBar()..showSnackBar(
                 const SnackBar(content: Text("\"Please enter a valid email address first.\""))
             );
            return;
       }
        ref.read(authViewModelProvider.notifier).sendPasswordResetEmail(email);
   }


  @override
  Widget build(BuildContext context) {
    final l10n = AppLocalizations.of(context)!;
    final state = ref.watch(authViewModelProvider); // Watch the state provider
    final bool isLoading = state is AuthUiLoading;

    // Listen for password reset success separately if needed
     ref.listen<AuthUiState>(authViewModelProvider, (_, next) {
        // Example: show specific message for password reset email sent
         next.showSnackbarOnPasswordResetSent(context, "\"Password reset email sent.\"");
         // Reset state after showing message?
         if (next is AuthUiPasswordResetSent) {
           Future.delayed(const Duration(milliseconds: 100), () {
              ref.read(authViewModelProvider.notifier).resetUiStateToIdle();
           });
         }
     });


    return SingleChildScrollView( // Allow scrolling on small screens
      padding: const EdgeInsets.all(24.0),
      child: Form(
        key: _formKey,
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.stretch,
          children: [
            const SizedBox(height: 20),

            // Email Field
            TextFormField(
              controller: _emailController,
              decoration: InputDecoration(
                labelText: l10n.emailHint,
                prefixIcon: const Icon(Icons.email_outlined),
                border: const OutlineInputBorder(),
              ),
              keyboardType: TextInputType.emailAddress,
              textInputAction: TextInputAction.next,
              validator: (value) {
                if (value == null || value.isEmpty || !value.contains('@')) {
                  return 'Please enter a valid email';
                }
                return null;
              },
              enabled: !isLoading,
            ),
            const SizedBox(height: 16),

            // Password Field
            TextFormField(
              controller: _passwordController,
              decoration: InputDecoration(
                labelText: l10n.passwordHint,
                prefixIcon: const Icon(Icons.lock_outline),
                border: const OutlineInputBorder(),
                
              ),
              obscureText: true, // Hide password
              textInputAction: TextInputAction.done,
              validator: (value) {
                if (value == null || value.isEmpty || value.length < 6) {
                  return 'Password must be at least 6 characters';
                }
                return null;
              },
               enabled: !isLoading,
               onFieldSubmitted: (_) => isLoading ? null : _submit(),
            ),
            const SizedBox(height: 8),

             // Forgot Password Link
             Align(
               alignment: AlignmentDirectional.centerEnd,
               child: TextButton(
                 onPressed: isLoading ? null : _forgotPassword,
                 child: Text(l10n.forgotPasswordPrompt),
               ),
             ),
            const SizedBox(height: 24),

            // Login Button
            ElevatedButton(
              style: ElevatedButton.styleFrom(
                  padding: const EdgeInsets.symmetric(vertical: 16)),
              onPressed: isLoading ? null : _submit,
              child: isLoading && state is! AuthUiPasswordResetSent
                  ? const SizedBox(height: 24, width: 24, child: CircularProgressIndicator(strokeWidth: 2, color: Colors.white))
                  : Text(l10n.loginButton),
            ),
            const SizedBox(height: 20),

             // Or Divider
             Row(children: <Widget>[
                const Expanded(child: Divider()),
                Padding(
                  padding: const EdgeInsets.symmetric(horizontal: 8.0),
                  child: Text("OR", style: Theme.of(context).textTheme.bodySmall),
                ),
                const Expanded(child: Divider()),
              ]),
             const SizedBox(height: 20),


            // Google Sign In Button
            OutlinedButton.icon(
               style: OutlinedButton.styleFrom(
                   padding: const EdgeInsets.symmetric(vertical: 12),
                   side: BorderSide(color: Colors.grey.shade300),
                 ),
              icon: Image.asset('assets/icons/google_logo.png', height: 20.0),
              label: Text(l10n.continueWithGoogle),
              onPressed: isLoading ? null : _submitGoogle,
            ),
            const SizedBox(height: 32),

            // Go to Sign Up Text Button
            Row(
              mainAxisAlignment: MainAxisAlignment.center,
              children: [
                Text(l10n.noAccountPrompt),
                TextButton(
                  onPressed: isLoading ? null : widget.onGoToSignUp,
                  child: Text(l10n.signupButton),
                ),
              ],
            ),
          ],
        ),
      ),
    );
  }
}"

--------------------
src\features\auth\presentation\signup_view.dart:
"import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:masarat_alnur/src/features/auth/presentation/auth_view_model.dart';
import 'package:flutter_gen/gen_l10n/app_localizations.dart';
// Import AsyncValueUI helper if needed for error display

class SignUpView extends ConsumerStatefulWidget {
  final VoidCallback onGoToSignIn;

  const SignUpView({super.key, required this.onGoToSignIn});

  @override
  ConsumerState<SignUpView> createState() => _SignUpViewState();
}

class _SignUpViewState extends ConsumerState<SignUpView> {
  final _formKey = GlobalKey<FormState>();
  final _emailController = TextEditingController();
  final _passwordController = TextEditingController();
  final _confirmPasswordController = TextEditingController();

  @override
  void dispose() {
    _emailController.dispose();
    _passwordController.dispose();
    _confirmPasswordController.dispose();
    super.dispose();
  }

  Future<void> _submit() async {
    if (_formKey.currentState!.validate()) {
       if (_passwordController.text != _confirmPasswordController.text) {
          ScaffoldMessenger.of(context)..hideCurrentSnackBar()..showSnackBar(
             const SnackBar(content: Text("\"Passwords do not match\""))
          );
          return;
       }
      final email = _emailController.text.trim();
      final password = _passwordController.text.trim();
      // Call ViewModel method
      ref
          .read(authViewModelProvider.notifier)
          .signUpWithEmailPassword(email, password);
    }
  }


  @override
  Widget build(BuildContext context) {
    final l10n = AppLocalizations.of(context)!;
    final state = ref.watch(authViewModelProvider);
    final bool isLoading = state is AuthUiLoading;

    return SingleChildScrollView(
      padding: const EdgeInsets.all(24.0),
      child: Form(
        key: _formKey,
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.stretch,
          children: [
             const SizedBox(height: 20), // Add some top spacing

            // Email Field
            TextFormField(
              controller: _emailController,
              decoration: InputDecoration( labelText: l10n.emailHint, prefixIcon: const Icon(Icons.email_outlined), border: const OutlineInputBorder()),
              keyboardType: TextInputType.emailAddress,
              textInputAction: TextInputAction.next,
              validator: (value) {
                 if (value == null || value.isEmpty || !value.contains('@')) return 'Please enter a valid email'; return null; },
              enabled: !isLoading,
            ),
            const SizedBox(height: 16),

            // Password Field
            TextFormField(
              controller: _passwordController,
              decoration: InputDecoration( labelText: l10n.passwordHint, prefixIcon: const Icon(Icons.lock_outline), border: const OutlineInputBorder()),
              obscureText: true,
              textInputAction: TextInputAction.next,
              validator: (value) {
                 if (value == null || value.isEmpty || value.length < 6) return 'Password must be at least 6 characters'; return null; },
               enabled: !isLoading,
            ),
             const SizedBox(height: 16),

             // Confirm Password Field
             TextFormField(
               controller: _confirmPasswordController,
               decoration: InputDecoration(labelText: l10n.confirmPasswordHint, prefixIcon: const Icon(Icons.lock_outline), border: const OutlineInputBorder()),
               obscureText: true,
               textInputAction: TextInputAction.done,
               validator: (value) {
                 if (value == null || value.isEmpty) {
                   return 'Please confirm your password';
                 }
                 if (value != _passwordController.text) {
                    return 'Passwords do not match';
                 }
                 return null;
               },
               enabled: !isLoading,
               onFieldSubmitted: (_) => isLoading ? null : _submit(),
             ),
            const SizedBox(height: 24),

            // SignUp Button
            ElevatedButton(
              style: ElevatedButton.styleFrom(
                  padding: const EdgeInsets.symmetric(vertical: 16)),
              onPressed: isLoading ? null : _submit,
              child: isLoading
                  ? const SizedBox(height: 24, width: 24, child: CircularProgressIndicator(strokeWidth: 2, color: Colors.white))
                  : Text(l10n.signupButton),
            ),
            const SizedBox(height: 32),

            // Go to Sign In Text Button
            Row(
              mainAxisAlignment: MainAxisAlignment.center,
              children: [
                 Text(l10n.haveAccountPrompt),
                TextButton(
                  onPressed: isLoading ? null : widget.onGoToSignIn,
                  child: Text(l10n.loginButton),
                ),
              ],
            ),
          ],
        ),
      ),
    );
  }
}"

--------------------
src\features\content\data\content_repository.dart:
"import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:riverpod_annotation/riverpod_annotation.dart';
import 'package:masarat_alnur/src/features/content/domain/category.dart';
import 'package:masarat_alnur/src/features/content/domain/sub_category.dart';
import 'package:masarat_alnur/src/features/content/domain/content_status.dart';
import 'package:masarat_alnur/src/features/auth/data/user_repository.dart';
import 'dart:math';

part 'content_repository.g.dart';

class ContentRepository {
  final FirebaseFirestore _firestore;
  
  ContentRepository(this._firestore);

  // Collection References
  CollectionReference<Category> _categoriesRef() =>
      _firestore.collection('categories').withConverter<Category>(
            fromFirestore: (snapshot, _) => Category(
              id: snapshot.id,
              title_ar: snapshot.data()?['title_ar'] ?? '',
              imageUrl: snapshot.data()?['imageUrl'],
              order: snapshot.data()?['order'] ?? 0,
              status: ContentStatus.values.firstWhere(
                (e) => e.name == (snapshot.data()?['status'] ?? 'PUBLISHED'),
                orElse: () => ContentStatus.PUBLISHED,
              ),
            ),
            toFirestore: (category, _) => {
              'title_ar': category.title_ar,
              if (category.imageUrl != null) 'imageUrl': category.imageUrl,
              'order': category.order,
              'status': category.status.name,
            },
          );

  CollectionReference<SubCategory> _subCategoriesRef() =>
      _firestore.collection('subCategories').withConverter<SubCategory>(
            fromFirestore: (snapshot, _) => SubCategory(
              id: snapshot.id,
              categoryId: snapshot.data()?['categoryId'] ?? '',
              title_ar: snapshot.data()?['title_ar'] ?? '',
              imageUrl: snapshot.data()?['imageUrl'],
              order: snapshot.data()?['order'] ?? 0,
              status: ContentStatus.values.firstWhere(
                (e) => e.name == (snapshot.data()?['status'] ?? 'PUBLISHED'),
                orElse: () => ContentStatus.PUBLISHED,
              ),
            ),
            toFirestore: (subCategory, _) => {
              'categoryId': subCategory.categoryId,
              'title_ar': subCategory.title_ar,
              if (subCategory.imageUrl != null) 'imageUrl': subCategory.imageUrl,
              'order': subCategory.order,
              'status': subCategory.status.name,
            },
          );

  // Fetch Methods
  Stream<List<Category>> watchCategories() {
    return _categoriesRef()
        .orderBy('order')
        .where('status', isEqualTo: ContentStatus.PUBLISHED.name)
        .snapshots()
        .map((snapshot) => snapshot.docs.map((doc) => doc.data()).toList());
  }

  Stream<List<SubCategory>> watchSubCategories(String categoryId) {
    return _subCategoriesRef()
        .where('categoryId', isEqualTo: categoryId)
        .orderBy('order')
        .where('status', isEqualTo: ContentStatus.PUBLISHED.name)
        .snapshots()
        .map((snapshot) => snapshot.docs.map((doc) => doc.data()).toList());
  }

  Stream<List<SubCategory>> watchAllSubCategories() {
    return _subCategoriesRef()
        .orderBy('order')
        .where('status', isEqualTo: ContentStatus.PUBLISHED.name)
        .snapshots()
        .map((snapshot) => snapshot.docs.map((doc) => doc.data()).toList());
  }

  Future<Category?> fetchCategory(String categoryId) async {
    final doc = await _categoriesRef().doc(categoryId).get();
    return doc.data();
  }

  Future<List<Category>> fetchOngoingCategories(List<String> categoryIds) async {
    if (categoryIds.isEmpty) return [];
    final snapshot = await _categoriesRef()
        .where(FieldPath.documentId, whereIn: categoryIds)
        .where('status', isEqualTo: ContentStatus.PUBLISHED.name)
        .get();
    return snapshot.docs.map((doc) => doc.data()).toList();
  }

  Future<List<SubCategory>> fetchOngoingSubCategories(List<String> subCategoryIds) async {
    if (subCategoryIds.isEmpty) return [];
    final snapshot = await _subCategoriesRef()
        .where(FieldPath.documentId, whereIn: subCategoryIds)
        .where('status', isEqualTo: ContentStatus.PUBLISHED.name)
        .get();
    return snapshot.docs.map((doc) => doc.data()).toList();
  }

  Future<SubCategory?> fetchSubCategory(String subCategoryId) async {
    final doc = await _subCategoriesRef().doc(subCategoryId).get();
    return doc.data();
  }

  Future<void> generateSampleData() async {
    // Get total number of existing categories
    final categoriesSnapshot = await _categoriesRef().get();
    final totalExistingCategories = categoriesSnapshot.size;

    // Generate 20 random categories
    for (int i = 1; i <= 20; i++) {
      final categoryId = _firestore.collection('categories').doc().id;
      await _categoriesRef().doc(categoryId).set(Category(
            id: categoryId,
            title_ar: '  ${totalExistingCategories + i}',
            imageUrl: 'https://picsum.photos/200/300?random=$i',
            order: totalExistingCategories + i,
          ));

      // Generate 10-15 random subcategories for each category
      final numSubCategories = 10 + Random().nextInt(6);
      for (int j = 1; j <= numSubCategories; j++) {
        final subCategoryId = _firestore.collection('subcategories').doc().id;
        await _subCategoriesRef().doc(subCategoryId).set(SubCategory(
              id: subCategoryId,
              categoryId: categoryId,
              title_ar: '   ${j}',
              imageUrl: 'https://picsum.photos/200/300?random=${i * 100 + j}',
              order: j,
            ));

        // Generate 10-15 random topics for each subcategory
        final numTopics = 10 + Random().nextInt(6);
        for (int k = 1; k <= numTopics; k++) {
          final topicId = _firestore.collection('topics').doc().id;
          await _firestore.collection('topics').doc(topicId).set({
            'id': topicId,
            'subCategoryId': subCategoryId,
            'title_ar': '  ${k}',
            'description_ar': '   ',
            'order': k,
            'status': 'PUBLISHED',
          });

          // Generate 3-8 random questions for each topic
          final numQuestions = 3 + Random().nextInt(6);
          for (int l = 1; l <= numQuestions; l++) {
            final numOptions = 3 + Random().nextInt(4);
            List<String> options = List.generate(
              numOptions,
              (index) => '  ${index + 1}',
            );

            await _firestore.collection('questions').add({
              'topicId': topicId,
              'question_ar': '  ${l} ',
              'options_ar': options,
              'correctOptionIndex': Random().nextInt(numOptions),
              'order': l,
              'explanation_ar': '      ${l}',
            });
          }
        }
      }
    }
  }
}

@Riverpod(keepAlive: true)
ContentRepository contentRepository(ContentRepositoryRef ref) {
  return ContentRepository(ref.watch(firebaseFirestoreProvider));
}

@riverpod
Stream<List<Category>> categoriesStream(CategoriesStreamRef ref) {
  return ref.watch(contentRepositoryProvider).watchCategories();
}

@riverpod
Stream<List<SubCategory>> subCategoriesStream(SubCategoriesStreamRef ref, String categoryId) {
  return ref.watch(contentRepositoryProvider).watchSubCategories(categoryId);
}

@riverpod
Stream<List<Category>> ongoingCategoriesStream(OngoingCategoriesStreamRef ref) {
  final userProgressAsync = ref.watch(userProgressStreamProvider);
  final contentRepo = ref.watch(contentRepositoryProvider);
  
  return userProgressAsync.when(
    data: (progress) {
      final startedIds = progress?.startedCategoryInfo.toList() ?? [];
      if (startedIds.isEmpty) return Stream.value([]);
      return Stream.fromFuture(contentRepo.fetchOngoingCategories(startedIds));
    },
    loading: () => Stream.value([]),
    error: (_, __) => Stream.value([]),
  );
}

@riverpod
Stream<List<SubCategory>> ongoingSubCategoriesStream(OngoingSubCategoriesStreamRef ref) {
  final userProgressAsync = ref.watch(userProgressStreamProvider);
  final contentRepo = ref.watch(contentRepositoryProvider);
  
  return userProgressAsync.when(
    data: (progress) {
      final startedIds = progress?.startedSubCategoryInfo.toList() ?? [];
      if (startedIds.isEmpty) return Stream.value([]);
      return Stream.fromFuture(contentRepo.fetchOngoingSubCategories(startedIds));
    },
    loading: () => Stream.value([]),
    error: (_, __) => Stream.value([]),
  );
}"

--------------------
src\features\content\data\content_repository.g.dart:
"// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'content_repository.dart';

// **************************************************************************
// RiverpodGenerator
// **************************************************************************

String _$contentRepositoryHash() => r'138c4315cdb92f02cec9895a1bcad327a24d1f34';

/// See also [contentRepository].
@ProviderFor(contentRepository)
final contentRepositoryProvider = Provider<ContentRepository>.internal(
  contentRepository,
  name: r'contentRepositoryProvider',
  debugGetCreateSourceHash:
      const bool.fromEnvironment('dart.vm.product')
          ? null
          : _$contentRepositoryHash,
  dependencies: null,
  allTransitiveDependencies: null,
);

@Deprecated('Will be removed in 3.0. Use Ref instead')
// ignore: unused_element
typedef ContentRepositoryRef = ProviderRef<ContentRepository>;
String _$categoriesStreamHash() => r'f6b402920f8ad9598b6f06b65211aaadd1585448';

/// See also [categoriesStream].
@ProviderFor(categoriesStream)
final categoriesStreamProvider =
    AutoDisposeStreamProvider<List<Category>>.internal(
      categoriesStream,
      name: r'categoriesStreamProvider',
      debugGetCreateSourceHash:
          const bool.fromEnvironment('dart.vm.product')
              ? null
              : _$categoriesStreamHash,
      dependencies: null,
      allTransitiveDependencies: null,
    );

@Deprecated('Will be removed in 3.0. Use Ref instead')
// ignore: unused_element
typedef CategoriesStreamRef = AutoDisposeStreamProviderRef<List<Category>>;
String _$subCategoriesStreamHash() =>
    r'615a568765078e77acb3cb6f7bf54bc61624ce45';

/// Copied from Dart SDK
class _SystemHash {
  _SystemHash._();

  static int combine(int hash, int value) {
    // ignore: parameter_assignments
    hash = 0x1fffffff & (hash + value);
    // ignore: parameter_assignments
    hash = 0x1fffffff & (hash + ((0x0007ffff & hash) << 10));
    return hash ^ (hash >> 6);
  }

  static int finish(int hash) {
    // ignore: parameter_assignments
    hash = 0x1fffffff & (hash + ((0x03ffffff & hash) << 3));
    // ignore: parameter_assignments
    hash = hash ^ (hash >> 11);
    return 0x1fffffff & (hash + ((0x00003fff & hash) << 15));
  }
}

/// See also [subCategoriesStream].
@ProviderFor(subCategoriesStream)
const subCategoriesStreamProvider = SubCategoriesStreamFamily();

/// See also [subCategoriesStream].
class SubCategoriesStreamFamily extends Family<AsyncValue<List<SubCategory>>> {
  /// See also [subCategoriesStream].
  const SubCategoriesStreamFamily();

  /// See also [subCategoriesStream].
  SubCategoriesStreamProvider call(String categoryId) {
    return SubCategoriesStreamProvider(categoryId);
  }

  @override
  SubCategoriesStreamProvider getProviderOverride(
    covariant SubCategoriesStreamProvider provider,
  ) {
    return call(provider.categoryId);
  }

  static const Iterable<ProviderOrFamily>? _dependencies = null;

  @override
  Iterable<ProviderOrFamily>? get dependencies => _dependencies;

  static const Iterable<ProviderOrFamily>? _allTransitiveDependencies = null;

  @override
  Iterable<ProviderOrFamily>? get allTransitiveDependencies =>
      _allTransitiveDependencies;

  @override
  String? get name => r'subCategoriesStreamProvider';
}

/// See also [subCategoriesStream].
class SubCategoriesStreamProvider
    extends AutoDisposeStreamProvider<List<SubCategory>> {
  /// See also [subCategoriesStream].
  SubCategoriesStreamProvider(String categoryId)
    : this._internal(
        (ref) => subCategoriesStream(ref as SubCategoriesStreamRef, categoryId),
        from: subCategoriesStreamProvider,
        name: r'subCategoriesStreamProvider',
        debugGetCreateSourceHash:
            const bool.fromEnvironment('dart.vm.product')
                ? null
                : _$subCategoriesStreamHash,
        dependencies: SubCategoriesStreamFamily._dependencies,
        allTransitiveDependencies:
            SubCategoriesStreamFamily._allTransitiveDependencies,
        categoryId: categoryId,
      );

  SubCategoriesStreamProvider._internal(
    super._createNotifier, {
    required super.name,
    required super.dependencies,
    required super.allTransitiveDependencies,
    required super.debugGetCreateSourceHash,
    required super.from,
    required this.categoryId,
  }) : super.internal();

  final String categoryId;

  @override
  Override overrideWith(
    Stream<List<SubCategory>> Function(SubCategoriesStreamRef provider) create,
  ) {
    return ProviderOverride(
      origin: this,
      override: SubCategoriesStreamProvider._internal(
        (ref) => create(ref as SubCategoriesStreamRef),
        from: from,
        name: null,
        dependencies: null,
        allTransitiveDependencies: null,
        debugGetCreateSourceHash: null,
        categoryId: categoryId,
      ),
    );
  }

  @override
  AutoDisposeStreamProviderElement<List<SubCategory>> createElement() {
    return _SubCategoriesStreamProviderElement(this);
  }

  @override
  bool operator ==(Object other) {
    return other is SubCategoriesStreamProvider &&
        other.categoryId == categoryId;
  }

  @override
  int get hashCode {
    var hash = _SystemHash.combine(0, runtimeType.hashCode);
    hash = _SystemHash.combine(hash, categoryId.hashCode);

    return _SystemHash.finish(hash);
  }
}

@Deprecated('Will be removed in 3.0. Use Ref instead')
// ignore: unused_element
mixin SubCategoriesStreamRef
    on AutoDisposeStreamProviderRef<List<SubCategory>> {
  /// The parameter `categoryId` of this provider.
  String get categoryId;
}

class _SubCategoriesStreamProviderElement
    extends AutoDisposeStreamProviderElement<List<SubCategory>>
    with SubCategoriesStreamRef {
  _SubCategoriesStreamProviderElement(super.provider);

  @override
  String get categoryId => (origin as SubCategoriesStreamProvider).categoryId;
}

String _$ongoingCategoriesStreamHash() =>
    r'efadecb76a0cec32d7749a963e4740b2901002f6';

/// See also [ongoingCategoriesStream].
@ProviderFor(ongoingCategoriesStream)
final ongoingCategoriesStreamProvider =
    AutoDisposeStreamProvider<List<Category>>.internal(
      ongoingCategoriesStream,
      name: r'ongoingCategoriesStreamProvider',
      debugGetCreateSourceHash:
          const bool.fromEnvironment('dart.vm.product')
              ? null
              : _$ongoingCategoriesStreamHash,
      dependencies: null,
      allTransitiveDependencies: null,
    );

@Deprecated('Will be removed in 3.0. Use Ref instead')
// ignore: unused_element
typedef OngoingCategoriesStreamRef =
    AutoDisposeStreamProviderRef<List<Category>>;
String _$ongoingSubCategoriesStreamHash() =>
    r'3a41a5082296068a265c1808bc54c8f5573bd86c';

/// See also [ongoingSubCategoriesStream].
@ProviderFor(ongoingSubCategoriesStream)
final ongoingSubCategoriesStreamProvider =
    AutoDisposeStreamProvider<List<SubCategory>>.internal(
      ongoingSubCategoriesStream,
      name: r'ongoingSubCategoriesStreamProvider',
      debugGetCreateSourceHash:
          const bool.fromEnvironment('dart.vm.product')
              ? null
              : _$ongoingSubCategoriesStreamHash,
      dependencies: null,
      allTransitiveDependencies: null,
    );

@Deprecated('Will be removed in 3.0. Use Ref instead')
// ignore: unused_element
typedef OngoingSubCategoriesStreamRef =
    AutoDisposeStreamProviderRef<List<SubCategory>>;
// ignore_for_file: type=lint
// ignore_for_file: subtype_of_sealed_class, invalid_use_of_internal_member, invalid_use_of_visible_for_testing_member, deprecated_member_use_from_same_package
"

--------------------
src\features\content\domain\category.dart:
"import 'package:equatable/equatable.dart';
import 'package:masarat_alnur/src/features/content/domain/content_status.dart'; // Import enum

// Using Equatable
class Category extends Equatable {
  final String id;
  final String title_ar;
  final String? imageUrl;
  final int order;
  final ContentStatus status;

  const Category({
    required this.id, // ID usually populated from Firestore document ID
    this.title_ar = '',
    this.imageUrl,
    this.order = 0,
    this.status = ContentStatus.PUBLISHED,
  });

  factory Category.empty() => const Category(id: '');

  @override
  List<Object?> get props => [id, title_ar, imageUrl, order, status];

  @override
  bool get stringify => true;

   Category copyWith({
     String? id,
     String? title_ar,
     String? imageUrl,
     bool clearImageUrl = false,
     int? order,
     ContentStatus? status,
   }) {
     return Category(
       id: id ?? this.id,
       title_ar: title_ar ?? this.title_ar,
       imageUrl: clearImageUrl ? null : (imageUrl ?? this.imageUrl),
       order: order ?? this.order,
       status: status ?? this.status,
     );
   }
}"

--------------------
src\features\content\domain\content_status.dart:
"enum ContentStatus {
  PUBLISHED,
  DRAFT,
}"

--------------------
src\features\content\domain\sub_category.dart:
"import 'package:equatable/equatable.dart';
import 'package:masarat_alnur/src/features/content/domain/content_status.dart';

class SubCategory extends Equatable {
  final String id;
  final String categoryId;
  final String title_ar;
  final String? imageUrl;
  final int order;
  final ContentStatus status;

  const SubCategory({
    required this.id,
    this.categoryId = '',
    this.title_ar = '',
    this.imageUrl,
    this.order = 0,
    this.status = ContentStatus.PUBLISHED,
  });

   factory SubCategory.empty() => const SubCategory(id: '');

  @override
  List<Object?> get props => [id, categoryId, title_ar, imageUrl, order, status];

  @override
  bool get stringify => true;

  // copyWith
   SubCategory copyWith({
     String? id,
     String? categoryId,
     String? title_ar,
     String? imageUrl,
     bool clearImageUrl = false,
     int? order,
     ContentStatus? status,
   }) {
     return SubCategory(
       id: id ?? this.id,
       categoryId: categoryId ?? this.categoryId,
       title_ar: title_ar ?? this.title_ar,
       imageUrl: clearImageUrl ? null : (imageUrl ?? this.imageUrl),
       order: order ?? this.order,
       status: status ?? this.status,
     );
   }
}"

--------------------
src\features\content\domain\topic.dart:
"import 'package:equatable/equatable.dart';
import 'package:masarat_alnur/src/features/content/domain/content_status.dart';

class Topic extends Equatable {
  final String id;
  final String subCategoryId;
  final String title_ar;
  final String description_ar;
  final int order;
  final ContentStatus status;

  const Topic({
    required this.id,
    this.subCategoryId = '',
    this.title_ar = '',
    this.description_ar = '',
    this.order = 0,
    this.status = ContentStatus.PUBLISHED,
  });

  factory Topic.empty() => const Topic(id: '');

  @override
  List<Object?> get props => [
        id,
        subCategoryId,
        title_ar,
        description_ar,
        order,
        status,
      ];

  @override
  bool get stringify => true;

  Topic copyWith({
    String? id,
    String? subCategoryId,
    String? title_ar,
    String? description_ar,
    int? order,
    ContentStatus? status,
  }) {
    return Topic(
      id: id ?? this.id,
      subCategoryId: subCategoryId ?? this.subCategoryId,
      title_ar: title_ar ?? this.title_ar,
      description_ar: description_ar ?? this.description_ar,
      order: order ?? this.order,
      status: status ?? this.status,
    );
  }
}"

--------------------
src\features\content\presentation\category_list_screen.dart:
"import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:go_router/go_router.dart';
import 'package:masarat_alnur/src/features/content/data/content_repository.dart';
import 'package:masarat_alnur/src/features/content/domain/category.dart';
import 'package:cached_network_image/cached_network_image.dart';
import 'package:flutter_gen/gen_l10n/app_localizations.dart';

class CategoryListScreen extends ConsumerWidget {
  final bool ongoingOnly;

  const CategoryListScreen({
    super.key,
    this.ongoingOnly = false,
  });

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final l10n = AppLocalizations.of(context)!;
    final categoriesAsync = ongoingOnly 
        ? ref.watch(ongoingCategoriesStreamProvider)
        : ref.watch(categoriesStreamProvider);

    return Scaffold(
      appBar: AppBar(
        leading: IconButton(
          icon: const Icon(Icons.arrow_back),
          onPressed: () => context.pop(),
        ),
        title: Text(l10n.categoriesSectionTitle),
      ),
      body: categoriesAsync.when(
        data: (categories) => categories.isEmpty 
            ? Center(
                child: Text(
                  ongoingOnly 
                      ? '    '  // No ongoing categories
                      : '  ',  // No categories
                  style: Theme.of(context).textTheme.titleMedium,
                ),
              )
            : GridView.builder(
                padding: const EdgeInsets.all(16),
                gridDelegate: const SliverGridDelegateWithFixedCrossAxisCount(
                  crossAxisCount: 2,
                  mainAxisSpacing: 16,
                  crossAxisSpacing: 16,
                  childAspectRatio: 0.75,
                ),
                itemCount: categories.length,
                itemBuilder: (context, index) {
                  final category = categories[index];
                  return _CategoryGridItem(category: category);
                },
              ),
        loading: () => const Center(child: CircularProgressIndicator()),
        error: (error, _) => Center(
          child: Text('Error: $error'),
        ),
      ),
    );
  }
}

class _CategoryGridItem extends StatelessWidget {
  final Category category;

  const _CategoryGridItem({required this.category});

  @override
  Widget build(BuildContext context) {
    return InkWell(
      onTap: () => context.push('/categories/${category.id}/subcategories'),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Expanded(
            child: ClipRRect(
              borderRadius: BorderRadius.circular(8),
              child: category.imageUrl != null
                  ? CachedNetworkImage(
                      imageUrl: category.imageUrl!,
                      fit: BoxFit.cover,
                      width: double.infinity,
                      placeholder: (context, url) => Container(
                        color: Colors.grey[300],
                        child: const Center(
                          child: CircularProgressIndicator(),
                        ),
                      ),
                      errorWidget: (context, url, error) => Container(
                        color: Colors.grey[300],
                        child: const Icon(Icons.category, size: 32),
                      ),
                    )
                  : Container(
                      color: Colors.grey[300],
                      child: const Icon(Icons.category, size: 32),
                    ),
            ),
          ),
          const SizedBox(height: 8),
          Text(
            category.title_ar,
            style: Theme.of(context).textTheme.titleMedium,
            maxLines: 2,
            overflow: TextOverflow.ellipsis,
          ),
        ],
      ),
    );
  }
}"

--------------------
src\features\content\presentation\sub_category_list_screen.dart:
"import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:go_router/go_router.dart';
import 'package:masarat_alnur/src/features/content/data/content_repository.dart';
import 'package:masarat_alnur/src/features/content/domain/sub_category.dart';
import 'package:cached_network_image/cached_network_image.dart';
import 'package:flutter_gen/gen_l10n/app_localizations.dart';

class SubCategoryListScreen extends ConsumerWidget {
  final String? categoryId;
  final bool ongoingOnly;
  final String? categoryName;

  const SubCategoryListScreen({
    super.key,
    this.categoryId,
    this.categoryName,
    this.ongoingOnly = false,
  });

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final l10n = AppLocalizations.of(context)!;
    
    // Watch appropriate stream based on mode
    final subCategoriesAsync = ongoingOnly
        ? ref.watch(ongoingSubCategoriesStreamProvider)
        : categoryId != null
            ? ref.watch(subCategoriesStreamProvider(categoryId!))
            : const AsyncValue<List<SubCategory>>.data([]);

    return Scaffold(
      appBar: AppBar(
        leading: IconButton(
          icon: const Icon(Icons.arrow_back),
          onPressed: () => context.pop(),
        ),
        title: Text(categoryName ?? l10n.ongoingSubCategoriesSectionTitle),
      ),
      body: subCategoriesAsync.when(
        data: (subCategories) => subCategories.isEmpty 
            ? Center(
                child: Text(
                  ongoingOnly 
                      ? '     '  // No ongoing subcategories
                      : '   ',  // No subcategories
                  style: Theme.of(context).textTheme.titleMedium,
                ),
              )
            : GridView.builder(
                padding: const EdgeInsets.all(16),
                gridDelegate: const SliverGridDelegateWithFixedCrossAxisCount(
                  crossAxisCount: 2,
                  mainAxisSpacing: 16,
                  crossAxisSpacing: 16,
                  childAspectRatio: 0.75,
                ),
                itemCount: subCategories.length,
                itemBuilder: (context, index) {
                  final subCategory = subCategories[index];
                  return InkWell(
                    onTap: () => context.push(
                      '/subcategories/${subCategory.id}/topics',
                      extra: subCategory.title_ar,
                    ),
                    child: Column(
                      children: [
                        Expanded(
                          child: ClipRRect(
                            borderRadius: BorderRadius.circular(8),
                            child: subCategory.imageUrl != null
                                ? CachedNetworkImage(
                                    imageUrl: subCategory.imageUrl!,
                                    fit: BoxFit.cover,
                                    width: double.infinity,
                                    placeholder: (context, url) => Container(
                                      color: Colors.grey[300],
                                      child: const Center(
                                        child: CircularProgressIndicator(),
                                      ),
                                    ),
                                    errorWidget: (context, url, error) =>
                                        Container(
                                      color: Colors.grey[300],
                                      child: const Icon(Icons.folder, size: 32),
                                    ),
                                  )
                                : Container(
                                    color: Colors.grey[300],
                                    child: const Icon(Icons.folder, size: 32),
                                  ),
                          ),
                        ),
                        const SizedBox(height: 8),
                        Text(
                          subCategory.title_ar,
                          style: Theme.of(context).textTheme.titleMedium,
                          maxLines: 2,
                          overflow: TextOverflow.ellipsis,
                          textAlign: TextAlign.center,
                        ),
                      ],
                    ),
                  );
                },
              ),
        loading: () => const Center(child: CircularProgressIndicator()),
        error: (error, _) => Center(
          child: Text('Error: $error'),
        ),
      ),
    );
  }
}"

--------------------
src\features\main_app\presentation\home_screen.dart:
"import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:go_router/go_router.dart';
import 'package:masarat_alnur/src/features/content/data/content_repository.dart';
import 'package:masarat_alnur/src/features/content/domain/category.dart';
import 'package:masarat_alnur/src/features/content/domain/sub_category.dart';
import 'package:flutter_gen/gen_l10n/app_localizations.dart';
import 'package:cached_network_image/cached_network_image.dart';

class HomeScreen extends ConsumerWidget {
  const HomeScreen({super.key});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final l10n = AppLocalizations.of(context)!;
    
    final categoriesAsync = ref.watch(categoriesStreamProvider);
    final ongoingCategoriesAsync = ref.watch(ongoingCategoriesStreamProvider);
    final ongoingSubCategoriesAsync = ref.watch(ongoingSubCategoriesStreamProvider);

    return Scaffold(
      body: SafeArea(
        child: SingleChildScrollView(
          padding: const EdgeInsets.symmetric(vertical: 16.0),
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              // All Categories Section
              _SectionHeader(
                title: l10n.categoriesSectionTitle,
                onShowAll: () => context.push('/categories'),
              ),
              const SizedBox(height: 8),
              SizedBox(
                height: 180,
                child: categoriesAsync.when(
                  data: (categories) => _CategorySlider(categories: categories),
                  loading: () => const Center(child: CircularProgressIndicator()),
                  error: (error, _) => Center(
                    child: Text('Error: $error'),
                  ),
                ),
              ),
              const SizedBox(height: 24),

              // Ongoing Categories Section (if any)
              ongoingCategoriesAsync.when(
                data: (categories) => categories.isNotEmpty
                    ? Column(
                        crossAxisAlignment: CrossAxisAlignment.start,
                        children: [
                          _SectionHeader(
                            title: l10n.ongoingCategoriesSectionTitle,
                            onShowAll: () => context.push('/categories/ongoing'),
                          ),
                          const SizedBox(height: 8),
                          SizedBox(
                            height: 180,
                            child: _CategorySlider(
                              categories: categories,
                            ),
                          ),
                          const SizedBox(height: 24),
                        ],
                      )
                    : const SizedBox.shrink(),
                loading: () => const SizedBox.shrink(),
                error: (_, __) => const SizedBox.shrink(),
              ),

              // Ongoing Sub-Categories Section (if any)
              ongoingSubCategoriesAsync.when(
                data: (subCategories) => subCategories.isNotEmpty
                    ? Column(
                        crossAxisAlignment: CrossAxisAlignment.start,
                        children: [
                          _SectionHeader(
                            title: l10n.ongoingSubCategoriesSectionTitle,
                            onShowAll: () =>
                                context.push('/subcategories/ongoing'),
                          ),
                          const SizedBox(height: 8),
                          SizedBox(
                            height: 180,
                            child: _SubCategorySlider(
                              subCategories: subCategories,
                            ),
                          ),
                          const SizedBox(height: 24),
                        ],
                      )
                    : const SizedBox.shrink(),
                loading: () => const SizedBox.shrink(),
                error: (_, __) => const SizedBox.shrink(),
              ),

              // Per-Category Sub-Categories Sections
              categoriesAsync.when(
                data: (categories) => Column(
                  children: categories.map((category) {
                    final subCategoriesAsync = ref.watch(
                      subCategoriesStreamProvider(category.id),
                    );
                    return subCategoriesAsync.when(
                      data: (subCategories) => subCategories.isNotEmpty
                          ? Column(
                              crossAxisAlignment: CrossAxisAlignment.start,
                              children: [
                                _SectionHeader(
                                  title: category.title_ar,
                                  onShowAll: () => context.push(
                                    '/categories/${category.id}/subcategories',
                                  ),
                                ),
                                const SizedBox(height: 8),
                                SizedBox(
                                  height: 180,
                                  child: _SubCategorySlider(
                                    subCategories: subCategories,
                                  ),
                                ),
                                const SizedBox(height: 24),
                              ],
                            )
                          : const SizedBox.shrink(),
                      loading: () => const SizedBox.shrink(),
                      error: (_, __) => const SizedBox.shrink(),
                    );
                  }).toList(),
                ),
                loading: () => const SizedBox.shrink(),
                error: (_, __) => const SizedBox.shrink(),
              ),
            ],
          ),
        ),
      ),
    );
  }
}

class _SectionHeader extends StatelessWidget {
  final String title;
  final VoidCallback onShowAll;

  const _SectionHeader({
    required this.title,
    required this.onShowAll,
  });

  @override
  Widget build(BuildContext context) {
    return Padding(
      padding: const EdgeInsets.symmetric(horizontal: 16.0),
      child: Row(
        mainAxisAlignment: MainAxisAlignment.spaceBetween,
        children: [
          Text(
            title,
            style: Theme.of(context).textTheme.titleLarge,
          ),
          TextButton(
            onPressed: onShowAll,
            child: Text(AppLocalizations.of(context)!.showAllButton),
          ),
        ],
      ),
    );
  }
}

class _CategorySlider extends StatelessWidget {
  final List<Category> categories;

  const _CategorySlider({required this.categories});

  @override
  Widget build(BuildContext context) {
    return ListView.builder(
      scrollDirection: Axis.horizontal,
      padding: const EdgeInsets.symmetric(horizontal: 16),
      itemCount: categories.length,
      itemBuilder: (context, index) {
        final category = categories[index];
        return Padding(
          padding: const EdgeInsets.only(right: 16),
          child: InkWell(
            onTap: () => context.push('/categories/${category.id}/subcategories'),
            child: SizedBox(
              width: 140,
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  ClipRRect(
                    borderRadius: BorderRadius.circular(8),
                    child: AspectRatio(
                      aspectRatio: 16 / 9,
                      child: category.imageUrl != null
                          ? CachedNetworkImage(
                              imageUrl: category.imageUrl!,
                              fit: BoxFit.cover,
                              placeholder: (context, url) => Container(
                                color: Colors.grey[300],
                                child: const Center(
                                  child: CircularProgressIndicator(),
                                ),
                              ),
                              errorWidget: (context, url, error) =>
                                  _CategoryPlaceholder(),
                            )
                          : _CategoryPlaceholder(),
                    ),
                  ),
                  const SizedBox(height: 8),
                  Text(
                    category.title_ar,
                    style: Theme.of(context).textTheme.titleMedium,
                    maxLines: 2,
                    overflow: TextOverflow.ellipsis,
                  ),
                ],
              ),
            ),
          ),
        );
      },
    );
  }
}

class _SubCategorySlider extends StatelessWidget {
  final List<SubCategory> subCategories;

  const _SubCategorySlider({required this.subCategories});

  @override
  Widget build(BuildContext context) {
    return ListView.builder(
      scrollDirection: Axis.horizontal,
      padding: const EdgeInsets.symmetric(horizontal: 16),
      itemCount: subCategories.length,
      itemBuilder: (context, index) {
        final subCategory = subCategories[index];
        return Padding(
          padding: const EdgeInsets.only(right: 16),
          child: InkWell(
            onTap: () => context.push('/subcategories/${subCategory.id}/topics'),
            child: SizedBox(
              width: 140,
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  ClipRRect(
                    borderRadius: BorderRadius.circular(8),
                    child: AspectRatio(
                      aspectRatio: 16 / 9,
                      child: subCategory.imageUrl != null
                          ? CachedNetworkImage(
                              imageUrl: subCategory.imageUrl!,
                              fit: BoxFit.cover,
                              placeholder: (context, url) => Container(
                                color: Colors.grey[300],
                                child: const Center(
                                  child: CircularProgressIndicator(),
                                ),
                              ),
                              errorWidget: (context, url, error) =>
                                  _SubCategoryPlaceholder(),
                            )
                          : _SubCategoryPlaceholder(),
                    ),
                  ),
                  const SizedBox(height: 8),
                  Text(
                    subCategory.title_ar,
                    style: Theme.of(context).textTheme.titleMedium,
                    maxLines: 2,
                    overflow: TextOverflow.ellipsis,
                  ),
                ],
              ),
            ),
          ),
        );
      },
    );
  }
}

class _CategoryPlaceholder extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return Container(
      color: Colors.grey[300],
      child: const Icon(Icons.category, size: 32),
    );
  }
}

class _SubCategoryPlaceholder extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return Container(
      color: Colors.grey[300],
      child: const Icon(Icons.folder, size: 32),
    );
  }
}"

--------------------
src\features\main_app\presentation\main_screen.dart:
"import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:flutter_gen/gen_l10n/app_localizations.dart';
import 'package:masarat_alnur/src/features/main_app/presentation/home_screen.dart';
import 'package:masarat_alnur/src/features/main_app/presentation/profile_screen.dart';

class MainScreen extends ConsumerStatefulWidget {
  const MainScreen({super.key});

  @override
  ConsumerState<MainScreen> createState() => _MainScreenState();
}

class _MainScreenState extends ConsumerState<MainScreen> {
  int _selectedIndex = 0;

  @override
  Widget build(BuildContext context) {
    final l10n = AppLocalizations.of(context)!;

    return Scaffold(
      body: IndexedStack(
        index: _selectedIndex,
        children: const [
          HomeScreen(),
          ProfileScreen(),
        ],
      ),
      bottomNavigationBar: BottomNavigationBar(
        items: <BottomNavigationBarItem>[
          BottomNavigationBarItem(
            icon: const Icon(Icons.home_outlined),
            activeIcon: const Icon(Icons.home),
            label: l10n.homeTab,
          ),
          BottomNavigationBarItem(
            icon: const Icon(Icons.person_outline),
            activeIcon: const Icon(Icons.person),
            label: l10n.profileTab,
          ),
        ],
        currentIndex: _selectedIndex,
        selectedItemColor: Theme.of(context).colorScheme.primary,
        onTap: (index) => setState(() => _selectedIndex = index),
      ),
    );
  }
}"

--------------------
src\features\main_app\presentation\profile_screen.dart:
"import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:go_router/go_router.dart';
import 'package:masarat_alnur/src/features/auth/data/auth_repository.dart';
import 'package:masarat_alnur/src/features/auth/data/user_repository.dart';
import 'package:masarat_alnur/src/features/content/data/content_repository.dart';
import 'package:flutter_gen/gen_l10n/app_localizations.dart';

class ProfileScreen extends ConsumerWidget {
  const ProfileScreen({super.key});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final userProfileAsync = ref.watch(userProfileStreamProvider);
    final userProgressAsync = ref.watch(userProgressStreamProvider);
    final isAdminAsync = ref.watch(isCurrentUserAdminProvider);
    final l10n = AppLocalizations.of(context)!;

    return Scaffold(
      body: SafeArea(
        child: Padding(
          padding: const EdgeInsets.all(16.0),
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.stretch,
            children: [
              // User Profile Section
              userProfileAsync.when(
                data: (userProfile) => Column(
                  children: [
                    const CircleAvatar(
                      radius: 50,
                      child: Icon(Icons.person, size: 50),
                    ),
                    const SizedBox(height: 16),
                    Text(
                      userProfile?.displayName ?? '',
                      style: Theme.of(context).textTheme.headlineMedium,
                      textAlign: TextAlign.center,
                    ),
                  ],
                ),
                loading: () => const Center(child: CircularProgressIndicator()),
                error: (error, stack) => const Text('    '),
              ),
              const SizedBox(height: 32),

              // Progress Statistics Section
              userProgressAsync.when(
                data: (progress) => Card(
                  child: Padding(
                    padding: const EdgeInsets.all(16.0),
                    child: Column(
                      crossAxisAlignment: CrossAxisAlignment.start,
                      children: [
                        Text(
                          '',
                          style: Theme.of(context).textTheme.titleLarge,
                        ),
                        const SizedBox(height: 16),
                        _StatisticTile(
                          icon: Icons.check_circle_outline,
                          title: l10n.profileTopicsCompletedLabel,
                          value: progress?.completedTopicIds.length ?? 0,
                        ),
                        const Divider(),
                        _StatisticTile(
                          icon: Icons.folder_open,
                          title: l10n.profileSubCategoriesCompletedLabel,
                          value: progress?.completedSubCategoryIds.length ?? 0,
                        ),
                        const Divider(),
                        _StatisticTile(
                          icon: Icons.category,
                          title: l10n.profileCategoriesCompletedLabel,
                          value: progress?.completedCategoryIds.length ?? 0,
                        ),
                      ],
                    ),
                  ),
                ),
                loading: () => const Center(child: CircularProgressIndicator()),
                error: (error, stack) => const Text('   '),
              ),

              const Spacer(),

              // Admin Section
              isAdminAsync.when(
                data: (isAdmin) => isAdmin
                    ? Column(
                        children: [
                          FilledButton.icon(
                            onPressed: () {
                              ref.read(contentRepositoryProvider).generateSampleData();
                              ScaffoldMessenger.of(context).showSnackBar(
                                const SnackBar(content: Text('   ')),
                              );
                            },
                            icon: const Icon(Icons.add),
                            label: const Text('  '),
                          ),
                          const SizedBox(height: 16),
                        ],
                      )
                    : const SizedBox.shrink(),
                loading: () => const SizedBox.shrink(),
                error: (_, __) => const SizedBox.shrink(),
              ),

              // Action Buttons
              FilledButton.icon(
                onPressed: () {
                  // TODO: Implement rate us functionality
                },
                icon: const Icon(Icons.star),
                label: Text(l10n.rateUsButton),
              ),
              const SizedBox(height: 8),
              OutlinedButton.icon(
                onPressed: () async {
                  await ref.read(authRepositoryProvider).signOut();
                  if (context.mounted) {
                    context.go('/onboarding/welcome');
                  }
                },
                icon: const Icon(Icons.logout),
                label: Text(l10n.logoutButton),
              ),
            ],
          ),
        ),
      ),
    );
  }
}

class _StatisticTile extends StatelessWidget {
  final IconData icon;
  final String title;
  final int value;

  const _StatisticTile({
    required this.icon,
    required this.title,
    required this.value,
  });

  @override
  Widget build(BuildContext context) {
    return Padding(
      padding: const EdgeInsets.symmetric(vertical: 8.0),
      child: Row(
        children: [
          Icon(icon),
          const SizedBox(width: 16),
          Expanded(
            child: Text(
              title,
              style: Theme.of(context).textTheme.bodyLarge,
            ),
          ),
          Text(
            value.toString(),
            style: Theme.of(context).textTheme.titleMedium,
          ),
        ],
      ),
    );
  }
}"

--------------------
src\features\onboarding\presentation\congrats_screen.dart:
"import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:go_router/go_router.dart';
import 'package:masarat_alnur/src/features/auth/data/auth_repository.dart';
import 'package:masarat_alnur/src/features/auth/data/user_repository.dart';

class CongratsScreen extends ConsumerWidget {
  const CongratsScreen({super.key});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final userProfileAsync = ref.watch(userProfileStreamProvider);
    final fbAuth = ref.watch(firebaseAuthProvider);
    
    // Get Firebase metadata
    final fbUser = fbAuth.currentUser;
    final isNewUser = fbUser != null && 
        fbUser.metadata.creationTime?.isAtSameMomentAs(
          fbUser.metadata.lastSignInTime ?? DateTime.now()
        ) == true;

    return Scaffold(
      body: Center(
        child: Padding(
          padding: const EdgeInsets.all(24.0),
          child: Column(
            mainAxisAlignment: MainAxisAlignment.center,
            children: [
              Text(
                isNewUser ? '!' : ' !',
                style: Theme.of(context).textTheme.headlineMedium,
                textAlign: TextAlign.center,
              ),
              const SizedBox(height: 16),
              userProfileAsync.when(
                data: (userProfile) => Text(
                  isNewUser 
                    ? '    ${userProfile?.displayName ?? ""}'
                    : '   ${userProfile?.displayName ?? ""}',
                  style: Theme.of(context).textTheme.bodyLarge,
                  textAlign: TextAlign.center,
                ),
                loading: () => const CircularProgressIndicator(),
                error: (error, stack) => Text(' : $error'),
              ),
              const SizedBox(height: 32),
              FilledButton(
                onPressed: () => context.go('/main'),
                child: const Text(''),
              ),
            ],
          ),
        ),
      ),
    );
  }
}"

--------------------
src\features\onboarding\presentation\onboarding_view_model.dart:
"import 'package:masarat_alnur/src/features/auth/data/auth_repository.dart'; // For user ID
import 'package:masarat_alnur/src/features/auth/data/user_repository.dart';
import 'package:riverpod_annotation/riverpod_annotation.dart';

part 'onboarding_view_model.g.dart';

@riverpod
class OnboardingViewModel extends _$OnboardingViewModel {

  // Build returns the initial state, can be void if no data needed initially
  @override
  FutureOr<void> build() {
    return null; // Or return Future.value(null);
  }

  // Get user repo dependency
  UserRepository get _userRepository => ref.read(userRepositoryProvider);
  // Get auth repo to find current user ID
  AuthRepository get _authRepository => ref.read(authRepositoryProvider);

  Future<bool> saveNickname(String nickname) async {
    // Use AsyncValue to represent state: loading, error, data (void means success)
    state = const AsyncLoading();
    final userId = _authRepository.currentUser?.uid;

    if (userId == null || userId.isEmpty) {
      state = AsyncError('User not logged in to save nickname.', StackTrace.current);
      return false;
    }
    if (nickname.trim().isEmpty || nickname.length < 3) {
        state = AsyncError('Invalid nickname provided.', StackTrace.current);
        return false;
    }

    try {
      await _userRepository.updateUserData(userId, displayName: nickname.trim());
      // Set state to data to indicate success, observers can react
      state = const AsyncData(null);
      return true;
    } catch (e, st) {
      state = AsyncError(e, st);
      return false;
    }
  }
}"

--------------------
src\features\onboarding\presentation\onboarding_view_model.g.dart:
"// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'onboarding_view_model.dart';

// **************************************************************************
// RiverpodGenerator
// **************************************************************************

String _$onboardingViewModelHash() =>
    r'10b330a6d20ed0b1b86c240622bbc9b4040f243f';

/// See also [OnboardingViewModel].
@ProviderFor(OnboardingViewModel)
final onboardingViewModelProvider =
    AutoDisposeAsyncNotifierProvider<OnboardingViewModel, void>.internal(
      OnboardingViewModel.new,
      name: r'onboardingViewModelProvider',
      debugGetCreateSourceHash:
          const bool.fromEnvironment('dart.vm.product')
              ? null
              : _$onboardingViewModelHash,
      dependencies: null,
      allTransitiveDependencies: null,
    );

typedef _$OnboardingViewModel = AutoDisposeAsyncNotifier<void>;
// ignore_for_file: type=lint
// ignore_for_file: subtype_of_sealed_class, invalid_use_of_internal_member, invalid_use_of_visible_for_testing_member, deprecated_member_use_from_same_package
"

--------------------
src\features\onboarding\presentation\welcome_screen.dart:
"import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:go_router/go_router.dart';
import 'package:masarat_alnur/src/app.dart'; // For AppRoute
import 'package:flutter_gen/gen_l10n/app_localizations.dart';

class WelcomeScreen extends ConsumerWidget {
  const WelcomeScreen({super.key});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final l10n = AppLocalizations.of(context)!;
    final textTheme = Theme.of(context).textTheme;
    final colorScheme = Theme.of(context).colorScheme;

    return Scaffold(
      body: SafeArea( // Use SafeArea
        child: Padding(
          padding: const EdgeInsets.all(24.0),
          child: Column(
            mainAxisAlignment: MainAxisAlignment.center,
            crossAxisAlignment: CrossAxisAlignment.stretch, // Stretch buttons
            children: [
              // TODO: Add your App Logo Widget here
              Icon(
                Icons.lightbulb_outline, size: 100, color: colorScheme.primary),
              const SizedBox(height: 32),
              Text(
                l10n.welcomeMessage,
                textAlign: TextAlign.center,
                style: textTheme.headlineMedium?.copyWith(fontWeight: FontWeight.bold),
              ),
              const SizedBox(height: 16),
              Text(
                l10n.welcomeTagline,
                textAlign: TextAlign.center,
                style: textTheme.titleMedium?.copyWith(color: Colors.grey[600]),
              ),
              const Spacer(), // Push button to bottom
              ElevatedButton(
                style: ElevatedButton.styleFrom(
                    padding: const EdgeInsets.symmetric(vertical: 16)),
                // Navigate to the Auth step
                onPressed: () => context.goNamed(AppRoute.onboardingAuth.name),
                child: Text(l10n.startButton),
              ),
              const SizedBox(height: 20), // Spacing at bottom
            ],
          ),
        ),
      ),
    );
  }
}"

--------------------
src\features\progress\domain\user_progress.dart:
"import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:equatable/equatable.dart';

class UserProgress extends Equatable {
  // Use userId as document ID, not stored in fields
  final List<String> completedTopicIds;
  final List<String> startedSubCategoryInfo;
  final List<String> completedSubCategoryIds;
  final List<String> startedCategoryInfo;
  final List<String> completedCategoryIds;

  const UserProgress({
    this.completedTopicIds = const [],
    this.startedSubCategoryInfo = const [],
    this.completedSubCategoryIds = const [],
    this.startedCategoryInfo = const [],
    this.completedCategoryIds = const [],
    
  });

  // Factory constructor for default empty state
   factory UserProgress.empty() => const UserProgress();

  // Firestore conversion requires careful handling of Timestamps and potentially Lists/Maps
   factory UserProgress.fromFirestore(DocumentSnapshot<Map<String, dynamic>> snapshot, SnapshotOptions? options) {
       final data = snapshot.data();
       // Helper to safely convert list fields
       List<String> listFromFirestore(dynamic list) {
           return (list as List<dynamic>?)?.map((e) => e.toString()).toList() ?? [];
       }

       return UserProgress(
           completedTopicIds: listFromFirestore(data?['completedTopicIds']),
           startedSubCategoryInfo: listFromFirestore(data?['startedSubCategoryInfo']),
           completedSubCategoryIds: listFromFirestore(data?['completedSubCategoryIds']),
           startedCategoryInfo: listFromFirestore(data?['startedCategoryInfo']),
           completedCategoryIds: listFromFirestore(data?['completedCategoryIds']),
       );
   }

   Map<String, dynamic> toFirestore() {
       return {
           'completedTopicIds': completedTopicIds,
           'startedSubCategoryInfo': startedSubCategoryInfo,
           'completedSubCategoryIds': completedSubCategoryIds,
           'startedCategoryInfo': startedCategoryInfo,
           'completedCategoryIds': completedCategoryIds,
       };
   }


  @override
  List<Object?> get props => [
        completedTopicIds,
        startedSubCategoryInfo,
        completedSubCategoryIds,
        startedCategoryInfo,
        completedCategoryIds,
      ];

  @override
  bool get stringify => true;

   // copyWith method for immutable updates
   UserProgress copyWith({
     List<String>? completedTopicIds,
     List<String>? startedSubCategoryInfo,
     List<String>? completedSubCategoryIds,
     List<String>? startedCategoryInfo,
     List<String>? completedCategoryIds,
   }) {
     return UserProgress(
       completedTopicIds: completedTopicIds ?? this.completedTopicIds,
       startedSubCategoryInfo: startedSubCategoryInfo ?? this.startedSubCategoryInfo,
       completedSubCategoryIds: completedSubCategoryIds ?? this.completedSubCategoryIds,
       startedCategoryInfo: startedCategoryInfo ?? this.startedCategoryInfo,
       completedCategoryIds: completedCategoryIds ?? this.completedCategoryIds,
     );
   }
}"

--------------------
src\features\quiz\data\quiz_repository.dart:
"import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:riverpod_annotation/riverpod_annotation.dart';
import 'package:masarat_alnur/src/features/quiz/domain/quiz_question.dart';
import 'package:masarat_alnur/src/features/quiz/domain/quiz_progress.dart';
import 'package:masarat_alnur/src/features/auth/data/user_repository.dart';
import 'package:masarat_alnur/src/features/content/domain/topic.dart';
import 'package:masarat_alnur/src/features/content/domain/content_status.dart';

part 'quiz_repository.g.dart';

class QuizRepository {
  final FirebaseFirestore _firestore;
  
  QuizRepository(this._firestore);

  // Collection References
  CollectionReference<Topic> _topicsRef() =>
      _firestore.collection('topics').withConverter<Topic>(
            fromFirestore: (snapshot, _) => Topic(
              id: snapshot.id,
              subCategoryId: snapshot.data()?['subCategoryId'] ?? '',
              title_ar: snapshot.data()?['title_ar'] ?? '',
              description_ar: snapshot.data()?['description_ar'] ?? '',
              order: snapshot.data()?['order'] ?? 0,
              status: ContentStatus.values.firstWhere(
                (e) => e.name == (snapshot.data()?['status'] ?? 'PUBLISHED'),
                orElse: () => ContentStatus.PUBLISHED,
              ),
            ),
            toFirestore: (topic, _) => {
              'subCategoryId': topic.subCategoryId,
              'title_ar': topic.title_ar,
              'description_ar': topic.description_ar,
              'order': topic.order,
              'status': topic.status.name,
            },
          );

  CollectionReference<QuizQuestion> _questionsRef() =>
      _firestore.collection('questions').withConverter<QuizQuestion>(
            fromFirestore: (snapshot, _) => QuizQuestion(
              id: snapshot.id,
              topicId: snapshot.data()?['topicId'] ?? '',
              question_ar: snapshot.data()?['question_ar'] ?? '',
              options_ar: List<String>.from(snapshot.data()?['options_ar'] ?? []),
              correctOptionIndex: snapshot.data()?['correctOptionIndex'] ?? 0,
              order: snapshot.data()?['order'] ?? 0,
              explanation_ar: snapshot.data()?['explanation_ar'],
            ),
            toFirestore: (question, _) => {
              'topicId': question.topicId,
              'question_ar': question.question_ar,
              'options_ar': question.options_ar,
              'correctOptionIndex': question.correctOptionIndex,
              'order': question.order,
              if (question.explanation_ar != null)
                'explanation_ar': question.explanation_ar,
            },
          );

  // Fetch Methods
  Stream<List<Topic>> watchTopics(String subCategoryId) {
    return _topicsRef()
        .where('subCategoryId', isEqualTo: subCategoryId)
        .orderBy('order')
        .where('status', isEqualTo: ContentStatus.PUBLISHED.name)
        .snapshots()
        .map((snapshot) => snapshot.docs.map((doc) => doc.data()).toList());
  }

  Stream<List<QuizQuestion>> watchQuestions(String topicId) {
    return _questionsRef()
        .where('topicId', isEqualTo: topicId)
        .orderBy('order')
        .snapshots()
        .map((snapshot) => snapshot.docs.map((doc) => doc.data()).toList());
  }

  Future<Topic?> fetchTopic(String topicId) async {
    final doc = await _topicsRef().doc(topicId).get();
    return doc.data();
  }

  // User Progress Methods
  Future<bool> saveAnswer(String userId, String questionId, int selectedOptionIndex) async {
    final progressRef = _firestore
        .collection('userProgress')
        .doc(userId)
        .collection('quizProgress');

    final QuizQuestion? question = await _questionsRef()
        .doc(questionId)
        .get()
        .then((doc) => doc.data());

    if (question == null) return false;

    final isCorrect = selectedOptionIndex == question.correctOptionIndex;
    
    // Update the progress document for this topic
    final progressDoc = progressRef.doc(question.topicId);
    final existingProgress = await progressDoc.get();

    if (!existingProgress.exists) {
      await progressDoc.set({
        'status': QuizStatus.IN_PROGRESS.name,
        'answers': isCorrect ? {questionId: selectedOptionIndex} : {},
        'lastAttemptDate': FieldValue.serverTimestamp(),
      });
    } else {
      final currentAnswers = (existingProgress.data()?['answers'] as Map<String, dynamic>?)?.cast<String, int>() ?? {};
      
      if (isCorrect) {
        currentAnswers[questionId] = selectedOptionIndex;
      }

      await progressDoc.update({
        'status': QuizStatus.IN_PROGRESS.name,
        'answers': currentAnswers,
        'lastAttemptDate': FieldValue.serverTimestamp(),
      });
    }

    return isCorrect;
  }

  Future<void> submitQuiz(String userId, String topicId, Map<String, int> answers) async {
    final questions = await _questionsRef()
        .where('topicId', isEqualTo: topicId)
        .get()
        .then((snapshot) => snapshot.docs.map((doc) => doc.data()).toList());

    int correctAnswers = 0;
    for (final question in questions) {
      final selectedAnswer = answers[question.id];
      if (selectedAnswer == question.correctOptionIndex) {
        correctAnswers++;
      }
    }

    final score = questions.isEmpty ? 0 : (correctAnswers / questions.length * 100).round();

    await _firestore
        .collection('userProgress')
        .doc(userId)
        .collection('quizProgress')
        .doc(topicId)
        .set({
          'status': QuizStatus.COMPLETED.name,
          'answers': answers,
          'score': score,
          'lastAttemptDate': FieldValue.serverTimestamp(),
        }, SetOptions(merge: true));
  }

  Stream<QuizProgress?> watchQuizProgress(String userId, String topicId) {
    return _firestore
        .collection('userProgress')
        .doc(userId)
        .collection('quizProgress')
        .doc(topicId)
        .snapshots()
        .map((doc) {
      if (!doc.exists) return null;

      return QuizProgress(
        topicId: topicId,
        status: QuizStatus.values.firstWhere(
          (e) => e.name == (doc.data()?['status'] ?? 'NOT_STARTED'),
          orElse: () => QuizStatus.NOT_STARTED,
        ),
        answers: Map<String, int>.from(doc.data()?['answers'] ?? {}),
        score: doc.data()?['score'] ?? 0,
        lastAttemptDate: (doc.data()?['lastAttemptDate'] as Timestamp?)?.toDate(),
      );
    });
  }
}

@Riverpod(keepAlive: true)
QuizRepository quizRepository(QuizRepositoryRef ref) {
  return QuizRepository(ref.watch(firebaseFirestoreProvider));
}

@riverpod
Stream<List<Topic>> topicsStream(TopicsStreamRef ref, String subCategoryId) {
  return ref.watch(quizRepositoryProvider).watchTopics(subCategoryId);
}

@riverpod
Stream<List<QuizQuestion>> questionsStream(QuestionsStreamRef ref, String topicId) {
  return ref.watch(quizRepositoryProvider).watchQuestions(topicId);
}

@riverpod
Stream<QuizProgress?> quizProgressStream(
  QuizProgressStreamRef ref, 
  String userId, 
  String topicId,
) {
  return ref.watch(quizRepositoryProvider).watchQuizProgress(userId, topicId);
}"

--------------------
src\features\quiz\data\quiz_repository.g.dart:
"// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'quiz_repository.dart';

// **************************************************************************
// RiverpodGenerator
// **************************************************************************

String _$quizRepositoryHash() => r'd2e7c0557e1cedfdaa0308e6a4d536aa0ac4adb0';

/// See also [quizRepository].
@ProviderFor(quizRepository)
final quizRepositoryProvider = Provider<QuizRepository>.internal(
  quizRepository,
  name: r'quizRepositoryProvider',
  debugGetCreateSourceHash:
      const bool.fromEnvironment('dart.vm.product')
          ? null
          : _$quizRepositoryHash,
  dependencies: null,
  allTransitiveDependencies: null,
);

@Deprecated('Will be removed in 3.0. Use Ref instead')
// ignore: unused_element
typedef QuizRepositoryRef = ProviderRef<QuizRepository>;
String _$topicsStreamHash() => r'c451f210776464eb26e4f97d9c0d187b3c3d79a4';

/// Copied from Dart SDK
class _SystemHash {
  _SystemHash._();

  static int combine(int hash, int value) {
    // ignore: parameter_assignments
    hash = 0x1fffffff & (hash + value);
    // ignore: parameter_assignments
    hash = 0x1fffffff & (hash + ((0x0007ffff & hash) << 10));
    return hash ^ (hash >> 6);
  }

  static int finish(int hash) {
    // ignore: parameter_assignments
    hash = 0x1fffffff & (hash + ((0x03ffffff & hash) << 3));
    // ignore: parameter_assignments
    hash = hash ^ (hash >> 11);
    return 0x1fffffff & (hash + ((0x00003fff & hash) << 15));
  }
}

/// See also [topicsStream].
@ProviderFor(topicsStream)
const topicsStreamProvider = TopicsStreamFamily();

/// See also [topicsStream].
class TopicsStreamFamily extends Family<AsyncValue<List<Topic>>> {
  /// See also [topicsStream].
  const TopicsStreamFamily();

  /// See also [topicsStream].
  TopicsStreamProvider call(String subCategoryId) {
    return TopicsStreamProvider(subCategoryId);
  }

  @override
  TopicsStreamProvider getProviderOverride(
    covariant TopicsStreamProvider provider,
  ) {
    return call(provider.subCategoryId);
  }

  static const Iterable<ProviderOrFamily>? _dependencies = null;

  @override
  Iterable<ProviderOrFamily>? get dependencies => _dependencies;

  static const Iterable<ProviderOrFamily>? _allTransitiveDependencies = null;

  @override
  Iterable<ProviderOrFamily>? get allTransitiveDependencies =>
      _allTransitiveDependencies;

  @override
  String? get name => r'topicsStreamProvider';
}

/// See also [topicsStream].
class TopicsStreamProvider extends AutoDisposeStreamProvider<List<Topic>> {
  /// See also [topicsStream].
  TopicsStreamProvider(String subCategoryId)
    : this._internal(
        (ref) => topicsStream(ref as TopicsStreamRef, subCategoryId),
        from: topicsStreamProvider,
        name: r'topicsStreamProvider',
        debugGetCreateSourceHash:
            const bool.fromEnvironment('dart.vm.product')
                ? null
                : _$topicsStreamHash,
        dependencies: TopicsStreamFamily._dependencies,
        allTransitiveDependencies:
            TopicsStreamFamily._allTransitiveDependencies,
        subCategoryId: subCategoryId,
      );

  TopicsStreamProvider._internal(
    super._createNotifier, {
    required super.name,
    required super.dependencies,
    required super.allTransitiveDependencies,
    required super.debugGetCreateSourceHash,
    required super.from,
    required this.subCategoryId,
  }) : super.internal();

  final String subCategoryId;

  @override
  Override overrideWith(
    Stream<List<Topic>> Function(TopicsStreamRef provider) create,
  ) {
    return ProviderOverride(
      origin: this,
      override: TopicsStreamProvider._internal(
        (ref) => create(ref as TopicsStreamRef),
        from: from,
        name: null,
        dependencies: null,
        allTransitiveDependencies: null,
        debugGetCreateSourceHash: null,
        subCategoryId: subCategoryId,
      ),
    );
  }

  @override
  AutoDisposeStreamProviderElement<List<Topic>> createElement() {
    return _TopicsStreamProviderElement(this);
  }

  @override
  bool operator ==(Object other) {
    return other is TopicsStreamProvider &&
        other.subCategoryId == subCategoryId;
  }

  @override
  int get hashCode {
    var hash = _SystemHash.combine(0, runtimeType.hashCode);
    hash = _SystemHash.combine(hash, subCategoryId.hashCode);

    return _SystemHash.finish(hash);
  }
}

@Deprecated('Will be removed in 3.0. Use Ref instead')
// ignore: unused_element
mixin TopicsStreamRef on AutoDisposeStreamProviderRef<List<Topic>> {
  /// The parameter `subCategoryId` of this provider.
  String get subCategoryId;
}

class _TopicsStreamProviderElement
    extends AutoDisposeStreamProviderElement<List<Topic>>
    with TopicsStreamRef {
  _TopicsStreamProviderElement(super.provider);

  @override
  String get subCategoryId => (origin as TopicsStreamProvider).subCategoryId;
}

String _$questionsStreamHash() => r'e16689c6ad0a57167130e20a42f7dfd816e0bd34';

/// See also [questionsStream].
@ProviderFor(questionsStream)
const questionsStreamProvider = QuestionsStreamFamily();

/// See also [questionsStream].
class QuestionsStreamFamily extends Family<AsyncValue<List<QuizQuestion>>> {
  /// See also [questionsStream].
  const QuestionsStreamFamily();

  /// See also [questionsStream].
  QuestionsStreamProvider call(String topicId) {
    return QuestionsStreamProvider(topicId);
  }

  @override
  QuestionsStreamProvider getProviderOverride(
    covariant QuestionsStreamProvider provider,
  ) {
    return call(provider.topicId);
  }

  static const Iterable<ProviderOrFamily>? _dependencies = null;

  @override
  Iterable<ProviderOrFamily>? get dependencies => _dependencies;

  static const Iterable<ProviderOrFamily>? _allTransitiveDependencies = null;

  @override
  Iterable<ProviderOrFamily>? get allTransitiveDependencies =>
      _allTransitiveDependencies;

  @override
  String? get name => r'questionsStreamProvider';
}

/// See also [questionsStream].
class QuestionsStreamProvider
    extends AutoDisposeStreamProvider<List<QuizQuestion>> {
  /// See also [questionsStream].
  QuestionsStreamProvider(String topicId)
    : this._internal(
        (ref) => questionsStream(ref as QuestionsStreamRef, topicId),
        from: questionsStreamProvider,
        name: r'questionsStreamProvider',
        debugGetCreateSourceHash:
            const bool.fromEnvironment('dart.vm.product')
                ? null
                : _$questionsStreamHash,
        dependencies: QuestionsStreamFamily._dependencies,
        allTransitiveDependencies:
            QuestionsStreamFamily._allTransitiveDependencies,
        topicId: topicId,
      );

  QuestionsStreamProvider._internal(
    super._createNotifier, {
    required super.name,
    required super.dependencies,
    required super.allTransitiveDependencies,
    required super.debugGetCreateSourceHash,
    required super.from,
    required this.topicId,
  }) : super.internal();

  final String topicId;

  @override
  Override overrideWith(
    Stream<List<QuizQuestion>> Function(QuestionsStreamRef provider) create,
  ) {
    return ProviderOverride(
      origin: this,
      override: QuestionsStreamProvider._internal(
        (ref) => create(ref as QuestionsStreamRef),
        from: from,
        name: null,
        dependencies: null,
        allTransitiveDependencies: null,
        debugGetCreateSourceHash: null,
        topicId: topicId,
      ),
    );
  }

  @override
  AutoDisposeStreamProviderElement<List<QuizQuestion>> createElement() {
    return _QuestionsStreamProviderElement(this);
  }

  @override
  bool operator ==(Object other) {
    return other is QuestionsStreamProvider && other.topicId == topicId;
  }

  @override
  int get hashCode {
    var hash = _SystemHash.combine(0, runtimeType.hashCode);
    hash = _SystemHash.combine(hash, topicId.hashCode);

    return _SystemHash.finish(hash);
  }
}

@Deprecated('Will be removed in 3.0. Use Ref instead')
// ignore: unused_element
mixin QuestionsStreamRef on AutoDisposeStreamProviderRef<List<QuizQuestion>> {
  /// The parameter `topicId` of this provider.
  String get topicId;
}

class _QuestionsStreamProviderElement
    extends AutoDisposeStreamProviderElement<List<QuizQuestion>>
    with QuestionsStreamRef {
  _QuestionsStreamProviderElement(super.provider);

  @override
  String get topicId => (origin as QuestionsStreamProvider).topicId;
}

String _$quizProgressStreamHash() =>
    r'17cf72d82c0b10dd9730c1b7ddd29bf0be9dc936';

/// See also [quizProgressStream].
@ProviderFor(quizProgressStream)
const quizProgressStreamProvider = QuizProgressStreamFamily();

/// See also [quizProgressStream].
class QuizProgressStreamFamily extends Family<AsyncValue<QuizProgress?>> {
  /// See also [quizProgressStream].
  const QuizProgressStreamFamily();

  /// See also [quizProgressStream].
  QuizProgressStreamProvider call(String userId, String topicId) {
    return QuizProgressStreamProvider(userId, topicId);
  }

  @override
  QuizProgressStreamProvider getProviderOverride(
    covariant QuizProgressStreamProvider provider,
  ) {
    return call(provider.userId, provider.topicId);
  }

  static const Iterable<ProviderOrFamily>? _dependencies = null;

  @override
  Iterable<ProviderOrFamily>? get dependencies => _dependencies;

  static const Iterable<ProviderOrFamily>? _allTransitiveDependencies = null;

  @override
  Iterable<ProviderOrFamily>? get allTransitiveDependencies =>
      _allTransitiveDependencies;

  @override
  String? get name => r'quizProgressStreamProvider';
}

/// See also [quizProgressStream].
class QuizProgressStreamProvider
    extends AutoDisposeStreamProvider<QuizProgress?> {
  /// See also [quizProgressStream].
  QuizProgressStreamProvider(String userId, String topicId)
    : this._internal(
        (ref) =>
            quizProgressStream(ref as QuizProgressStreamRef, userId, topicId),
        from: quizProgressStreamProvider,
        name: r'quizProgressStreamProvider',
        debugGetCreateSourceHash:
            const bool.fromEnvironment('dart.vm.product')
                ? null
                : _$quizProgressStreamHash,
        dependencies: QuizProgressStreamFamily._dependencies,
        allTransitiveDependencies:
            QuizProgressStreamFamily._allTransitiveDependencies,
        userId: userId,
        topicId: topicId,
      );

  QuizProgressStreamProvider._internal(
    super._createNotifier, {
    required super.name,
    required super.dependencies,
    required super.allTransitiveDependencies,
    required super.debugGetCreateSourceHash,
    required super.from,
    required this.userId,
    required this.topicId,
  }) : super.internal();

  final String userId;
  final String topicId;

  @override
  Override overrideWith(
    Stream<QuizProgress?> Function(QuizProgressStreamRef provider) create,
  ) {
    return ProviderOverride(
      origin: this,
      override: QuizProgressStreamProvider._internal(
        (ref) => create(ref as QuizProgressStreamRef),
        from: from,
        name: null,
        dependencies: null,
        allTransitiveDependencies: null,
        debugGetCreateSourceHash: null,
        userId: userId,
        topicId: topicId,
      ),
    );
  }

  @override
  AutoDisposeStreamProviderElement<QuizProgress?> createElement() {
    return _QuizProgressStreamProviderElement(this);
  }

  @override
  bool operator ==(Object other) {
    return other is QuizProgressStreamProvider &&
        other.userId == userId &&
        other.topicId == topicId;
  }

  @override
  int get hashCode {
    var hash = _SystemHash.combine(0, runtimeType.hashCode);
    hash = _SystemHash.combine(hash, userId.hashCode);
    hash = _SystemHash.combine(hash, topicId.hashCode);

    return _SystemHash.finish(hash);
  }
}

@Deprecated('Will be removed in 3.0. Use Ref instead')
// ignore: unused_element
mixin QuizProgressStreamRef on AutoDisposeStreamProviderRef<QuizProgress?> {
  /// The parameter `userId` of this provider.
  String get userId;

  /// The parameter `topicId` of this provider.
  String get topicId;
}

class _QuizProgressStreamProviderElement
    extends AutoDisposeStreamProviderElement<QuizProgress?>
    with QuizProgressStreamRef {
  _QuizProgressStreamProviderElement(super.provider);

  @override
  String get userId => (origin as QuizProgressStreamProvider).userId;
  @override
  String get topicId => (origin as QuizProgressStreamProvider).topicId;
}

// ignore_for_file: type=lint
// ignore_for_file: subtype_of_sealed_class, invalid_use_of_internal_member, invalid_use_of_visible_for_testing_member, deprecated_member_use_from_same_package
"

--------------------
src\features\quiz\domain\quiz_progress.dart:
"import 'package:equatable/equatable.dart';

enum QuizStatus {
  NOT_STARTED,
  IN_PROGRESS,
  COMPLETED,
}

class QuizProgress extends Equatable {
  final String topicId;
  final QuizStatus status;
  final Map<String, int> answers; // questionId -> selectedOptionIndex
  final int score;
  final DateTime? lastAttemptDate;

  const QuizProgress({
    required this.topicId,
    this.status = QuizStatus.NOT_STARTED,
    this.answers = const {},
    this.score = 0,
    this.lastAttemptDate,
  });

  factory QuizProgress.empty() => const QuizProgress(topicId: '');

  @override
  List<Object?> get props => [topicId, status, answers, score, lastAttemptDate];

  @override
  bool get stringify => true;

  QuizProgress copyWith({
    String? topicId,
    QuizStatus? status,
    Map<String, int>? answers,
    int? score,
    DateTime? lastAttemptDate,
    bool clearLastAttemptDate = false,
  }) {
    return QuizProgress(
      topicId: topicId ?? this.topicId,
      status: status ?? this.status,
      answers: answers ?? this.answers,
      score: score ?? this.score,
      lastAttemptDate: clearLastAttemptDate ? null : (lastAttemptDate ?? this.lastAttemptDate),
    );
  }
}"

--------------------
src\features\quiz\domain\quiz_question.dart:
"import 'package:equatable/equatable.dart';

class QuizQuestion extends Equatable {
  final String id;
  final String topicId;
  final String question_ar;
  final List<String> options_ar;
  final int correctOptionIndex;
  final int order;
  final String? explanation_ar;

  const QuizQuestion({
    required this.id,
    required this.topicId,
    required this.question_ar,
    required this.options_ar,
    required this.correctOptionIndex,
    required this.order,
    this.explanation_ar,
  });

  factory QuizQuestion.empty() => const QuizQuestion(
        id: '',
        topicId: '',
        question_ar: '',
        options_ar: [],
        correctOptionIndex: 0,
        order: 0,
      );

  @override
  List<Object?> get props => [
        id,
        topicId,
        question_ar,
        options_ar,
        correctOptionIndex,
        order,
        explanation_ar,
      ];

  @override
  bool get stringify => true;

  QuizQuestion copyWith({
    String? id,
    String? topicId,
    String? question_ar,
    List<String>? options_ar,
    int? correctOptionIndex,
    int? order,
    String? explanation_ar,
  }) {
    return QuizQuestion(
      id: id ?? this.id,
      topicId: topicId ?? this.topicId,
      question_ar: question_ar ?? this.question_ar,
      options_ar: options_ar ?? this.options_ar,
      correctOptionIndex: correctOptionIndex ?? this.correctOptionIndex,
      order: order ?? this.order,
      explanation_ar: explanation_ar ?? this.explanation_ar,
    );
  }
}"

--------------------
src\features\quiz\presentation\quiz_screen.dart:
"import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:go_router/go_router.dart';
import 'package:masarat_alnur/src/features/quiz/data/quiz_repository.dart';
import 'package:masarat_alnur/src/features/quiz/domain/quiz_question.dart';
import 'package:masarat_alnur/src/features/auth/data/auth_repository.dart';
import 'package:masarat_alnur/src/features/content/domain/topic.dart';
import 'package:masarat_alnur/src/features/content/data/content_repository.dart';
import 'package:masarat_alnur/src/features/auth/data/user_repository.dart';

class QuizScreen extends ConsumerStatefulWidget {
  final String topicId;

  const QuizScreen({
    super.key,
    required this.topicId,
  });

  @override
  ConsumerState<QuizScreen> createState() => _QuizScreenState();
}

class _QuizScreenState extends ConsumerState<QuizScreen> {
  late PageController _pageController;
  final Map<String, int> _answers = {};
  final Map<String, bool> _checkedAnswers = {};
  String? _currentQuestionId;
  bool _showCompleted = false;
  String? _subCategoryId;

  @override
  void initState() {
    super.initState();
    _pageController = PageController();
    _loadTopicInfo();
  }

  @override
  void dispose() {
    _pageController.dispose();
    super.dispose();
  }

  Future<void> _loadTopicInfo() async {
    final topic = await ref.read(quizRepositoryProvider).fetchTopic(widget.topicId);
    if (topic != null) {
      setState(() {
        _subCategoryId = topic.subCategoryId;
      });

      // Get the category ID
      final subCategory = await ref.read(contentRepositoryProvider).fetchSubCategory(topic.subCategoryId);
      if (subCategory != null) {
        final currentUser = ref.read(authStateChangesProvider).value;
        if (currentUser != null) {
          // Mark subcategory and category as started
          await ref.read(userRepositoryProvider).updateSubCategoryStarted(currentUser.uid, topic.subCategoryId);
          await ref.read(userRepositoryProvider).updateCategoryStarted(currentUser.uid, subCategory.categoryId);
        }
      }
    }
  }

  Future<void> _checkAnswer(String questionId, int selectedIndex) async {
    final currentUser = ref.read(authStateChangesProvider).value;
    if (currentUser == null) return;

    final isCorrect = await ref
        .read(quizRepositoryProvider)
        .saveAnswer(currentUser.uid, questionId, selectedIndex);

    setState(() {
      if (isCorrect) {
        _answers[questionId] = selectedIndex;
      }
      _currentQuestionId = questionId;
      _checkedAnswers[questionId] = isCorrect;
    });
  }

  void _nextQuestion() {
    final questions = ref.read(questionsStreamProvider(widget.topicId)).value ?? [];
    final currentIndex = questions.indexWhere((q) => q.id == _currentQuestionId);
    if (currentIndex < questions.length - 1) {
      setState(() {
        _checkedAnswers.remove(_currentQuestionId);
      });
      _pageController.nextPage(
        duration: const Duration(milliseconds: 300),
        curve: Curves.easeInOut,
      );
    } else {
      // Quiz completed, mark topic as complete
      _completeQuiz();
    }
  }

  Future<void> _completeQuiz() async {
    final currentUser = ref.read(authStateChangesProvider).value;
    if (currentUser == null) return;

    // Submit final answers and get score
    await ref
        .read(quizRepositoryProvider)
        .submitQuiz(currentUser.uid, widget.topicId, _answers);

    // Mark topic as complete - this will trigger subcategory and category completion checks
    await ref
        .read(userRepositoryProvider)
        .markTopicAsComplete(currentUser.uid, widget.topicId);

    setState(() {
      _showCompleted = true;
    });
  }

  void _retryQuestion() {
    setState(() {
      _checkedAnswers.remove(_currentQuestionId);
      _answers.remove(_currentQuestionId);  // Also clear the selected answer
    });
  }

  Future<void> _handleButtonPress() async {
    if (_currentQuestionId == null) return;

    if (!_checkedAnswers.containsKey(_currentQuestionId!)) {
      // Check answer
      await _checkAnswer(_currentQuestionId!, _answers[_currentQuestionId!]!);
      return;
    }

    final isCorrect = _checkedAnswers[_currentQuestionId!] ?? false;
    if (!isCorrect) {
      // Retry question
      _retryQuestion();
      return;
    }

    // Next question or complete
    _nextQuestion();
  }

  Future<void> _navigateToNextTopic(BuildContext context) async {
    if (_subCategoryId == null) return;
    
    // Get all topics for this subcategory
    final topics = await ref
        .read(quizRepositoryProvider)
        .watchTopics(_subCategoryId!)
        .first;

    // Sort topics by order
    final sortedTopics = List<Topic>.from(topics)
      ..sort((a, b) => a.order.compareTo(b.order));

    // Find current topic index
    final currentIndex = sortedTopics.indexWhere((t) => t.id == widget.topicId);
    
    // If there's a next topic, navigate to it
    if (currentIndex < sortedTopics.length - 1) {
      final nextTopic = sortedTopics[currentIndex + 1];
      if (context.mounted) {
        context.pushReplacement('/topics/${nextTopic.id}/quiz');
      }
    } else {
      // No more topics, go back to topics list
      if (context.mounted) {
        context.pop();
      }
    }
  }

  @override
  Widget build(BuildContext context) {
    final questionsAsync = ref.watch(questionsStreamProvider(widget.topicId));

    return Scaffold(
      appBar: AppBar(
        leading: IconButton(
          icon: const Icon(Icons.close),
          onPressed: () => context.pop(),
        ),
        title: const Text(''), // Quiz
      ),
      body: questionsAsync.when(
        data: (questions) {
          if (questions.isEmpty) {
            return const Center(
              child: Text('   '), // No questions available
            );
          }

          if (_showCompleted) {
            return Center(
              child: Padding(
                padding: const EdgeInsets.all(16),
                child: Column(
                  mainAxisAlignment: MainAxisAlignment.center,
                  children: [
                    const Icon(Icons.check_circle_outline, size: 64, color: Colors.green),
                    const SizedBox(height: 16),
                    Text(
                      ' !',
                      style: Theme.of(context).textTheme.titleLarge,
                    ),
                    const SizedBox(height: 32),
                    FilledButton(
                      onPressed: () => _navigateToNextTopic(context),
                      child: const Text(' '),
                    ),
                    const SizedBox(height: 16),
                    OutlinedButton(
                      onPressed: () => context.pop(),
                      child: const Text('   '),
                    ),
                  ],
                ),
              ),
            );
          }

          return Column(
            children: [
              LinearProgressIndicator(
                value: (_answers.length) / questions.length,
                backgroundColor: Colors.grey[200],
              ),
              Expanded(
                child: PageView.builder(
                  controller: _pageController,
                  physics: const NeverScrollableScrollPhysics(),
                  itemCount: questions.length,
                  itemBuilder: (context, index) {
                    final question = questions[index];
                    return _QuestionCard(
                      question: question,
                      selectedAnswer: _answers[question.id],  // Just pass the current answer
                      showCorrectAnswer: _checkedAnswers.containsKey(question.id),
                      onAnswerSelected: _checkedAnswers.containsKey(question.id) ? 
                          null : 
                          (selectedIndex) {
                            setState(() {
                              _currentQuestionId = question.id;
                              _answers[question.id] = selectedIndex;
                            });
                          },
                    );
                  },
                ),
              ),
              Padding(
                padding: const EdgeInsets.all(16),
                child: SizedBox(
                  width: double.infinity,
                  child: FilledButton(
                    onPressed: _currentQuestionId == null || 
                        (_answers[_currentQuestionId!] == null && !_checkedAnswers.containsKey(_currentQuestionId!))
                        ? null 
                        : _handleButtonPress,
                    child: Text(_getButtonText()),
                  ),
                ),
              ),
            ],
          );
        },
        loading: () => const Center(child: CircularProgressIndicator()),
        error: (error, _) => Center(
          child: Text('Error: $error'),
        ),
      ),
    );
  }

  String _getButtonText() {
    if (_currentQuestionId == null) {
      return ''; // Check
    }

    if (!_checkedAnswers.containsKey(_currentQuestionId!)) {
      return ''; // Check
    }

    final isCorrect = _checkedAnswers[_currentQuestionId!] ?? false;
    if (!isCorrect) {
      return ' '; // Try Again
    }

    final questions = ref.read(questionsStreamProvider(widget.topicId)).value ?? [];
    final currentIndex = questions.indexWhere((q) => q.id == _currentQuestionId);
    if (currentIndex == questions.length - 1) {
      return ''; // Done
    }

    return ' '; // Next Question
  }
}

class _QuestionCard extends StatelessWidget {
  final QuizQuestion question;
  final int? selectedAnswer;
  final bool showCorrectAnswer;
  final ValueChanged<int>? onAnswerSelected;

  const _QuestionCard({
    required this.question,
    this.selectedAnswer,
    this.showCorrectAnswer = false,
    this.onAnswerSelected,
  });

  @override
  Widget build(BuildContext context) {
    return SingleChildScrollView(
      padding: const EdgeInsets.all(16),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Text(
            question.question_ar,
            style: Theme.of(context).textTheme.titleLarge,
          ),
          const SizedBox(height: 24),
          ...List.generate(
            question.options_ar.length,
            (index) {
              final isSelected = selectedAnswer == index;
              final isCorrect = showCorrectAnswer && index == question.correctOptionIndex;
              final isWrong = showCorrectAnswer && isSelected && !isCorrect;

              return Padding(
                padding: const EdgeInsets.only(bottom: 16),
                child: InkWell(
                  onTap: !showCorrectAnswer
                      ? () => onAnswerSelected?.call(index)
                      : null,
                  borderRadius: BorderRadius.circular(8),
                  child: Container(
                    padding: const EdgeInsets.all(16),
                    decoration: BoxDecoration(
                      border: Border.all(
                        color: isWrong
                            ? Colors.red
                            : isCorrect
                                ? Colors.green
                                : isSelected
                                    ? Theme.of(context).colorScheme.primary
                                    : Colors.grey[300]!,
                        width: isSelected ? 2 : 1,
                      ),
                      borderRadius: BorderRadius.circular(8),
                      color: isWrong
                          ? Colors.red.withOpacity(0.1)
                          : isCorrect
                              ? Colors.green.withOpacity(0.1)
                              : null,
                    ),
                    child: Row(
                      children: [
                        Expanded(
                          child: Text(
                            question.options_ar[index],
                            style: Theme.of(context).textTheme.bodyLarge,
                          ),
                        ),
                        if (showCorrectAnswer && (isCorrect || isWrong))
                          Icon(
                            isCorrect
                                ? Icons.check_circle_outline
                                : Icons.cancel_outlined,
                            color: isCorrect ? Colors.green : Colors.red,
                          ),
                      ],
                    ),
                  ),
                ),
              );
            },
          ),
          if (showCorrectAnswer && question.explanation_ar != null) ...[
            const SizedBox(height: 24),
            Text(
              ':', // Explanation:
              style: Theme.of(context).textTheme.titleMedium,
            ),
            const SizedBox(height: 8),
            Text(
              question.explanation_ar!,
              style: Theme.of(context).textTheme.bodyMedium,
            ),
          ],
        ],
      ),
    );
  }
}"

--------------------
src\features\quiz\presentation\topic_list_screen.dart:
"import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:go_router/go_router.dart';
import 'package:masarat_alnur/src/features/quiz/data/quiz_repository.dart';
import 'package:masarat_alnur/src/features/content/domain/topic.dart';
import 'package:masarat_alnur/src/features/quiz/domain/quiz_progress.dart';
import 'package:masarat_alnur/src/features/auth/data/auth_repository.dart';
import 'package:flutter_gen/gen_l10n/app_localizations.dart';

class TopicListScreen extends ConsumerWidget {
  final String subCategoryId;
  final String? subCategoryName;

  const TopicListScreen({
    super.key,
    required this.subCategoryId,
    this.subCategoryName,
  });

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final l10n = AppLocalizations.of(context)!;
    final topicsAsync = ref.watch(topicsStreamProvider(subCategoryId));
    final currentUser = ref.watch(authStateChangesProvider).value;

    return Scaffold(
      appBar: AppBar(
        title: Text(subCategoryName ?? l10n.topicsTitle),
        leading: IconButton(
          icon: const Icon(Icons.arrow_back),
          onPressed: () => context.pop(),
        ),
      ),
      body: topicsAsync.when(
        data: (topics) => topics.isEmpty
            ? Center(
                child: Text(
                  '   ',  // No topics available
                  style: Theme.of(context).textTheme.titleMedium,
                ),
              )
            : ListView.builder(
                padding: const EdgeInsets.all(16),
                itemCount: topics.length,
                itemBuilder: (context, index) {
                  final topic = topics[index];
                  if (currentUser != null) {
                    return _TopicProgressCard(
                      topic: topic,
                      userId: currentUser.uid,
                    );
                  }
                  return _TopicCard(topic: topic);
                },
              ),
        loading: () => const Center(child: CircularProgressIndicator()),
        error: (error, _) => Center(
          child: Text('Error: $error'),
        ),
      ),
    );
  }
}

class _TopicCard extends StatelessWidget {
  final Topic topic;

  const _TopicCard({required this.topic});

  @override
  Widget build(BuildContext context) {
    return Card(
      margin: const EdgeInsets.only(bottom: 16),
      child: InkWell(
        onTap: () => context.push('/topics/${topic.id}/quiz'),
        child: Padding(
          padding: const EdgeInsets.all(16),
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              Text(
                topic.title_ar,
                style: Theme.of(context).textTheme.titleMedium,
              ),
              if (topic.description_ar.isNotEmpty) ...[
                const SizedBox(height: 8),
                Text(
                  topic.description_ar,
                  style: Theme.of(context).textTheme.bodyMedium,
                ),
              ],
            ],
          ),
        ),
      ),
    );
  }
}

class _TopicProgressCard extends ConsumerWidget {
  final Topic topic;
  final String userId;

  const _TopicProgressCard({
    required this.topic,
    required this.userId,
  });

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final progressAsync = ref.watch(
      quizProgressStreamProvider(userId, topic.id),
    );

    return Card(
      margin: const EdgeInsets.only(bottom: 16),
      child: InkWell(
        onTap: () => context.push('/topics/${topic.id}/quiz'),
        child: Padding(
          padding: const EdgeInsets.all(16),
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              Row(
                children: [
                  Expanded(
                    child: Text(
                      topic.title_ar,
                      style: Theme.of(context).textTheme.titleMedium,
                    ),
                  ),
                  progressAsync.when(
                    data: (progress) {
                      if (progress == null) {
                        return const Icon(Icons.play_circle_outline);
                      }
                      switch (progress.status) {
                        case QuizStatus.NOT_STARTED:
                          return const Icon(Icons.play_circle_outline);
                        case QuizStatus.IN_PROGRESS:
                          return const Icon(Icons.pause_circle_outline);
                        case QuizStatus.COMPLETED:
                          return Row(
                            mainAxisSize: MainAxisSize.min,
                            children: [
                              Text(
                                '${progress.score}%',
                                style: Theme.of(context).textTheme.bodyMedium,
                              ),
                              const SizedBox(width: 8),
                              const Icon(Icons.check_circle_outline),
                            ],
                          );
                      }
                    },
                    loading: () => const SizedBox(
                      width: 16,
                      height: 16,
                      child: CircularProgressIndicator(strokeWidth: 2),
                    ),
                    error: (_, __) => const Icon(Icons.error_outline),
                  ),
                ],
              ),
              if (topic.description_ar.isNotEmpty) ...[
                const SizedBox(height: 8),
                Text(
                  topic.description_ar,
                  style: Theme.of(context).textTheme.bodyMedium,
                ),
              ],
            ],
          ),
        ),
      ),
    );
  }
}"

--------------------
src\features\splash\presentation\splash_screen.dart:
"import 'package:flutter/material.dart';

class SplashScreen extends StatelessWidget {
  const SplashScreen({super.key});

  @override
  Widget build(BuildContext context) {
    // GoRouter's redirect logic handles navigation away from splash.
    // This screen just shows a loading indicator or logo while redirect happens.
    return const Scaffold(
      body: Center(
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
             // TODO: Replace with your actual App Logo widget
             Icon(Icons.book_online, size: 80, color: Colors.deepPurple),
             SizedBox(height: 20),
             Text(" ", style: TextStyle(fontSize: 24, fontWeight: FontWeight.bold)),
             SizedBox(height: 40),
            CircularProgressIndicator(),
          ],
        ),
      ),
    );
  }
}"

--------------------
src\utils\async_value_ui.dart:
"import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:masarat_alnur/src/features/auth/presentation/auth_view_model.dart'; // Import AuthUiState and related types

extension AsyncValueUI on AsyncValue<dynamic> { // Use dynamic or specific type if needed
  /// Shows a Snackbar when the AsyncValue is an error, does nothing otherwise.
  void showSnackbarOnError(BuildContext context) {
    if (!isLoading && hasError && !hasValue) { // Ensure it's an error state
      final message = error is Exception
          ? (error as Exception).toString() // Show exception message
          : error?.toString() ?? 'An unknown error occurred'; // Fallback

      ScaffoldMessenger.of(context)
        ..hideCurrentSnackBar() // Hide previous snackbar if any
        ..showSnackBar(
          SnackBar(
            content: Text(message),
            backgroundColor: Theme.of(context).colorScheme.error,
          ),
        );
    }
  }
   // Helper to show a success snackbar if needed (example)
    void showSnackbarOnSuccess(BuildContext context, String message) {
       if (!isLoading && !hasError && hasValue) {
           ScaffoldMessenger.of(context)
               ..hideCurrentSnackBar()
               ..showSnackBar(SnackBar(content: Text(message)));
       }
    }
}

// Extension for AuthUiState
extension AuthUiStateUI on AuthUiState {
   void showSnackBarOnError(BuildContext context) {
       if (this is AuthUiError) {
          final errorState = this as AuthUiError;
          ScaffoldMessenger.of(context)
             ..hideCurrentSnackBar()
             ..showSnackBar(
                SnackBar(
                   content: Text(errorState.message),
                   backgroundColor: Theme.of(context).colorScheme.error,
                 ),
              );
       }
   }

    void showSnackbarOnPasswordResetSent(BuildContext context, String message) {
       if (this is AuthUiPasswordResetSent) {
          ScaffoldMessenger.of(context)
             ..hideCurrentSnackBar()
             ..showSnackBar(SnackBar(content: Text(message)));
       }
    }
}"

--------------------
